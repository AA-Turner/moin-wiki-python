=== NOTE: ["../py2app"] should be used instead of bundlebuilder whenever possible. ===
 
Building applications on MacOS X is very easy using bundlebuilder.py.
 
First create your app building script like so:
 
{{{
#!python
### makeapplication.py
from bundlebuilder import buildapp
 
buildapp(
    name='Application.app', # what to build
    mainprogram='main.py', # your app's main()
    argv_emulation=1, # drag&dropped filenames show up in sys.argv
    iconfile='myapp.icns', # file containing your app's icons
    standalone=1, # make this app self contained.
    includeModules=[], # list of additional Modules to force in
    includePackages=[], # list of additional Packages to force in
    libs=[], # list of shared libs or Frameworks to include
)
 
### end of makeapplication.py
}}}
 
Then do this:
{{{
% python makeapplication.py build
}}}
 
That command should create a stand-alone application bundle in build/Application.app.
Try running it! It may
work, but it probably needs a little help first.
 
When you run your makeapplication.py, there will most likely be
a few warnings. These can usually be ignored safely. Also, there may
be additional modules and libraries that your application requires that
buildapp() couldn't determine it needed to include. You can add those it missed using
its includeModules and includePacakges arguments.
 
When building a stand-alone application that uses additional Frameworks besides the Python.Framework, you can have
buildapp() include them for you using its libs argument. For example, if your application uses [http://tcltkaqua.sourceforge.net/ Tkinter], you'd use this:
 
{{{
#!python
buildapp(
    ...
    standalone=1,
    libs = [
            '/Library/Frameworks/Tk.Framework',
            '/Library/Frameworks/Tcl.Framework'
        ]
    ...
)
}}}
Building a stand-alone application creates an application bundle which contains everything it needs to run including
its own copy of the Python.Framework. If that's not to your liking, you can
build using 'semi-standalone=1' instead. This will make your application
bundle smaller as it won't include python, but it does require that your
users already have a working python installed.
 
'''Standalone bundles built on MacOS X 10.3 using its bundled Python 2.3 framework will not work on previous versions
of MacOS X.'''
 
On MacOS X 10.3,
Apple has included a full 2.3 Python.Framework for you which will work
with semi-standalone applications just fine. This makes building
a standalone application for 10.3 somewhat pointless as the bundles you
build there are not backwards compatable with previous versions of MacOS X.
On 10.3, a semi-standalone application will work AND be much smaller.
 
There are other options you can set in the call to buildapp(). See the
bundlebuilder.py module for the rest of them. In addition, all of them can be set from the command-line instead.
Here the complete command-line usage:
 
{{{
Usage:
  python bundlebuilder.py [options] command
  python mybuildscript.py [options] command
 
Commands:
  build build the application
  report print a report
 
Options:
  -b, --builddir=DIR the build directory; defaults to "build"
  -n, --name=NAME application name
  -r, --resource=FILE extra file or folder to be copied to Resources
  -f, --file=SRC:DST extra file or folder to be copied into the bundle;
                         DST must be a path relative to the bundle root
  -e, --executable=FILE the executable to be used
  -m, --mainprogram=FILE the Python main program
  -a, --argv add a wrapper main program to create sys.argv
  -p, --plist=FILE .plist file (default: generate one)
      --nib=NAME main nib name
  -c, --creator=CCCC 4-char creator code (default: '????')
      --iconfile=FILE
afa
 filename of the icon (an .icns file) to be used
                         as the Finder icon
      --bundle-id=ID the CFBundleIdentifier, in reverse-dns format
                         (eg. org.python.BuildApplet; this is used for
                         the preferences file name)
  -l, --link symlink files/folder instead of copying them
      --link-exec symlink the executable instead of copying it
      --standalone build a standalone application, which is fully
                         independent of a Python installation
      --semi-standalone build a standalone application, which depends on
                         an installed Python, yet includes all third-party
                         modules.
      --python=FILE Python to use in #! line in stead of current Python
      --lib=FILE shared library or framework to be copied into
                         the bundle
  -x, --exclude=MODULE exclude module (with --(semi-)standalone)
  -i, --include=MODULE include module (with --(semi-)standalone)
      --package=PACKAGE include a whole package (with --(semi-)standalone)
      --strip strip binaries (remove debug info)
  -v, --verbose increase verbosity level
  -q, --quiet decrease verbosity level
  -h, --help print this message
}}}
