#language en

This page describes parts of the Path class design which are in discussion. It is meant to show the current state of the discussion, so when we reach a consensus, we can delete all the discussion details and just write the decision.

Please write here your opinions. I (Noam) am terribly sorry, but due to lack of time (I don't sleep enough already) I only wrote my opinions. Please write yours, or write that you agree, so that we'll know if we agree on something or have to discuss it more.

The page is divided into sections, to make it easy to see what is said about what. Please open new sections if you have new subjects to discuss.

= Representation =

'''agreed:''' A logical representation is better than a string representation.  

Mike: p[:] should appear to be a tuple of path components (directories and the final filename).  str(p) should return a platform-specific string representing the entire path.   {{{p[:-1]}}} should return a new Path containing only the sliced components.  This eliminates the need for several properties/methods: .parent, .name, .join(), .split(), etc.  Does 'p1 + p2' mean join paths?  Does 'p1 + string' mean convert string to Path and join it?  Or does it mean append the string to the filename (useful for adding extensions)?  Should we disallow '+' entirely because of this ambiguity?

Noam: Do you mean that p[:] shouldn't return a path object? If so, why? path objects can behave just like tuples. p1 + p2 means join paths, and has the same meaning as tuple concatenation (it fails if p2 isn't relative). I think p1 + string should mean p1 + path(string), because that's the behaviour most similiar to p1 + p2. I don't think that it should add extensions - just use {{{p[:-1] + (p[-1]+'.ext')}}}. I don't see this as an ambiguity - concatenation to the last element isn't consistent with the tuple behaviour.


== One sequence or several parts? ==

Noam: A sequence. As Mike has said, a sequence allows for slicing to work simply. I think that's the main reason to use a sequence. Besides, you don't have to remember several attributes which save the data of the path: it's all in the sequence. About a different attribute for extensions: I don't like it. I think that extensions should make the logical representation more complex. See the section about extensions for a proposed solution.

Mike: Some concepts are better expressed as attributes rather than embedded in the sequence.  "Absolute/relative" is one; "rooted from which drive" is another.

Noam: That would require slicing to guess what you mean. Should p[:3] preserve the root element? Should p[1:3] preserve it? If the root element is the first element, it's all clear. I have nothing against the absolute/relative attribute, since it's just an easy way to examine the data stored in the sequence (namely, is the first element a subclass of Root). But I think that attributes storing data not found in the sequence are complicating matters.

== A seperate class for files and directories? ==

Noam: I don't like it. Sometimes I don't know whether a path is a file or directory - for example, "svn add FILE" adds a file if it's a file and recursively adds all the files in the directory if it's a directory. It does so by examining FILE to see whether it's a file or a directory. I think that a path is representation of "how to get to somewhere on the filesystem", and it can result in a file, a directory, a symbolic link, or simply not exist.

Jason: I don't like it.  It seems like I've worked with APIs like this and it's a pain.  It doesn't let you remain uncertain about it.  What do you do with isfile() and isdir() in this sort of design?

Mike: the advantage is that some methods apply only to files and others to directories, and having 30 methods in one object is a lot.  .isfile() and .isdir() becomes unnecessary in most cases: you simply do the desired operation (e.g., rmdir), and if the wrong type of object is found (file instead of directory or vice-versa), raise DirectoryError (subclass of PathError).  Call .purge() beforehand if you're creating a file/directory and don't mind overwriting whatever was there before.  As for shell command arguments ("svn add"), you have to manually convert the Path to an appropriate string anyway.

Noam: In the svn example, I meant: How would you write a program which gets an argument and doesn't know if it's a file or a directory? In the one class suggestion, you simply do "path(arg).isdir()". What would you do in your suggestion? And remember that paths may represent symbolic links to things, and even broken symbolic links!

== Inheritance from str to allow easy use in other functions ==

Noam, Mike: This won't work.  Strings must slice by character, and this is incompatible with slicing by directory component.

== Inheritance from tuple ==

Noam: I think it works well. Guido said that he didn't like it, but I don't understand why. If all the data is stored in the sequence, I think a sequence interface should be provided. As far as I can see, the tuple interface is just that: an interface for an immutable sequence. This means that it doesn't cause any unwanted restrictions, so I don't see why not to inherit from it.

Jason: I suggest making it look like a sequence without actually subclassing tuple.  It is rather strange to be subclassing tuple this way.

Noam: (My previous statement wasn't well formed) I guess this may be left to Guido's decision. I feel that subclassing from tuple is fine, but I don't really care.

Mike: the top level can emulate tuple slicing/addition to return a new Path object.  It doesn't have to *subclass* tuple.

Noam: Can you please elaborate about why not to subclass from tuple?

== A different class for special treatment of symbolic links ==

(Nick proposed that)

Noam, Jason, Mike: I think it complicates matters, and I don't see what's the benefit. On the contrary: I think that specifying the kind of method to use is clearer than stating it once and forgetting about it.

== Root element storing the separator ==

Noam:

I don't like that. I think that you should have a subclass for each platform, which is responsible for parsing a string and for formatting a string. For example, I saw in the macpath class that relative paths on the old mac start with ':'. I don't think that a root element can handle that.

I think that it makes much sense to have a different subclass for each platform: There are other things which are different for different platforms (some methods only available on one platform and not the other). A URL will also be another subclass, with its own appropriate methods.

Mike: The platform modules (posixpath, ntpath, etc) already exist and are the logical place for these Path classes.  Having the separators as class attributes is a convenience for the user, so why not?

Noam: I don't think they are the logical place for the path classes. I don't want to write a separate class for every platform. I want a class for every platform, that inherits most of the functionality from a common base class. This means that all path classes will be in the same module.

Why make the separators attributes of the root element? They have nothing to do with it. They should be attributes of the path class.

== Immutability ==

Noam, Jason, Mike: I think that immutable paths are somewhat easier to implement, and allow usage as dictionary keys. I think that if we have managed to live so far without mutable strings, we will manage to live without mutable paths. I don't see this as a major issue, but immutable paths can be somewhat more efficient: you can hash the string representation, and you can make sure you have a path by writing things like {{{ dst=path(dst) }}}, and if dst is already a path, no new object will be created.


= Extensions =

'''agreed:''' extensions are a common and platform-specific convention, so treating them should be made easy by the class.  

Noam:
I think that the basic representation should ignore extension conventions, as it doesn't matter for the path - the walk from one node to another. How about using string subclasses instead of normal strings for elements, that would behave exactly like normal strings but would allow some extension operations? For example, you would be able to write things like {{{ p[-1].ext }}}.

The interface should be defined: How should we distinguish between a file with an empty extension ("a.") and a file without an extension ("a")? And what should be the methods, anyway?

Mike: subclassing str is impractical due to the string/unicode duality.  Why not path properties: p.ext, p.name (name without extension).  The full filename is p[-1] so it doesn't need a property.
Whether an apparent extension *is* an extension is up to the user, so never treat it as an extension unless the user explicitly invokes an extension-related property or method.

= Stat =

Mike (quoted from an email):

Not sure about this.  I see the point in not duplicating .foo() vs
.stat().foo.  .foo() exists in os.path to avoid the ugliness of
os.stat() in the middle of an expression.  I think the current
recommendation is to just do stats all the time because the overhead
is minimal and it's not worth getting out of sync.

The question is, does forcing people to use .stat() expose an
implementation detail that should be hidden, and does it smell of
Unixism?  Most people think a file *is* a regular file or a directory.
 The fact that this is encoded in the file's permission bits -- which
stat() examines -- is a quirk of Unix.

Noam:
I think that calling stat once is a reasonable thing. Where I work we have a really slow network, and you feel every filesystem call. I also think that calling stat repeatedly may cause synchronization bugs: the stat may change while the logic already assumes something about it.

I don't see stat as a unixism - what's wrong about getting information about a file?

Mike: There's no logical reason why .stat() traditionally contains certain diverse information but not other information.   Why should the user have to look one place for statted information and another place for non-statted, when the distinction is arbitrary?  os.path.getsize() and os.path.getmtime() duplicate stat() information but were considered important enough to add later, why?

Noam: I think that os.path.getmtime(path) was added because os.stat(path).st_mtime looked ugly. I think that path.stat().mtime is fine. What do you think?

= Finding files =

Nick:
Swiss army methods are even more evil than wide APIs. And I consider the term 'glob' itself to be a Unixism - I've found the technique to be far more commonly known as wildcard matching in the Windows world.

Noam:

Can you give examples why this proposed method is evil? I think that the basic pattern idea is well defined. It gets three arguments. topdown is, I think, well defined and may be useful. onlyfiles and onlydirs are well defined and are only a convinience. I don't really mind ommitting them.

About the name "glob": I have nothing against glob, but if you find another name for the method, I might have nothing against it either.

Jason:  Hard-won knowledge here:  d.files('*.html') is just right.  This is the common use case.  glob() overgeneralizes it, forcing me to write d.glob('*.html', filesonly=True).  Yuck.

Guido strongly prefers multiple APIs for distinct use cases, as opposed to a single API that serves all the use cases by providing boolean flags that toggle various aspects of its behavior.

Noam:

I see what you mean. How about "glob" doing what it does in the current proposal, without the "onlyfiles" and "onlydirs" arguments, and "files" and "dirs" getting exactly the same arguments but yielding only files and directories, respectively?

About the "l" versions: Having glob, files, dirs, lglob, lfiles, ldirs seems ugly. Perhaps this ''should'' go in as a flag, say, "follow_symlinks=True"? (I would put it after pattern, because remembering the string "topdown" is easier. I don't think of any better name than "follow_symlinks". I also tend to think that it is more useful.)

Mike: Non-recursive lists: listdir, files, dirs, symlinks.  Recursive iterators: walk, walkfiles, walkdirs, walklinks.  All except *links should take a 'symlinks' argument, default True, meaning follow symlinks.  If false, never return a symlink.  The user can call *links to get the symlinks separately if desired.  listdir should have a 'names_only' argument, default False, meaning return the same as os.listdir().  Doesn't a 'pattern' argument eliminate the need for .glob()?

Noam: Can you explain why you think that "listdir, files, dirs, walk, walkfiles, walkdirs" is bettern than "glob, files, dirs"? I prefer three over six. About "links" methods - Do you have examples of when they are useful? Thinking about it, it seems that dirs+files should cover all the files in the directory, when symlinks are considered directories if they point to directories in the follow_symlinks mode. About the names_only: I don't like an attribute which changes the type of the result. You can always do x[-1] to get the base name.

= Expand =

Noam:
I removed expand. There's no need to use normpath, so it's equivalent
to .expanduser().expandvars(), and I think that the explicit form is
better.

Mike:
Expand is useful though, so you don't forget one or the other.

Noam:
I wouldn't want to call expandvars() by default - I think that expanding environment variables is something that should be done with care, as it may expose info about the environment which should be kept private. Anyway, I think that p.expanduser().expandvars() shows exactly what is being done and isn't a lot longer, so I prefer it.

= copytree =

Mike:
Er, not sure I've used it, but it seems useful.  Why force people to
reinvent the wheel with their own recursive loops that they may get
wrong?

Nick:

Because the handling of exceptional cases is almost always going to be 
application specific. Note that even os.walk provides a callback hook for if 
the call to os.listdir() fails when attempting to descend into a directory.

For copytree, the issues to be considered are significantly worse:
   - what to do if listdir fails in the source tree?
   - what to do if reading a file fails in the source tree?
   - what to do if a directory doesn't exist in the target tree?
   - what to do if a directory already exists in the target tree?
   - what to do if a file already exists in the target tree?
   - what to do if writing a file fails in the target tree?
   - should the file contents/mode/time be copied to the target tree?
   - what to do with symlinks in the source tree?

Now, what might potentially be genuinely useful is paired walk methods that 
allowed the following:
{{{
   # Do path.walk over this directory, and also return the corresponding
   # information for a destination directory (so the dest dir information
   # probably *won't* match that file system
   for src_info, dest_info in src_path.pairedwalk(dest_path):
       src_dirpath, src_subdirs, src_files = src_info
       dest_dirpath, dest_subdirs, dest_files = dest_info
       # Do something useful

   # Ditto for path.walkdirs
   for src_dirpath, dest_dirpath in src_path.pairedwalkdirs(dest_path):
       # Do something useful

   # Ditto for path.walkfiles
   for src_path, dest_path in src_path.pairedwalkfiles(dest_path):
       src_path.copy_to(dest_path)
}}}

Jason:  I think Python needs high-level APIs to do stuff like copytree().  The current state of affairs is just awful.  On Unix I can do os.system('cp ' + ...), but it's not portable.

I haven't tried pairedwalkfiles(), so no opinion.

Mike: .pairedwalk() and friends may be useful.  The user wants to know which files/directories to create, update, and delete.  So it's essentially a diff report.

Noam: I'm not sure about pairedwalk() - it may be a bit complicated, I'm afraid. However, perhaps copytree() isn't such a big deal if it works only when the source is a directory and the destination doesn't exist. Then, exceptions aren't expected, so if they happen they can simply be propagated.

= Copy =

Nick:

OK, this is one case where a swiss army method may make sense. Specifically, 
something like:

   def copy_to(self, dest, copyfile=True, copymode=True, copytime=False)

Whether or not to copy the file contents, the permission settings and the last access and modification time are then all independently selectable.

The different method name also makes the direction of the copying clear (with a bare 'copy', it's slightly ambiguous as the 'cp src dest' parallel isn't as strong as it is with a function).

Noam:
I think the different name and arguments are a good idea. What exactly does the copyfile argument mean?

Jason:  Definitely agree with Nick.

Noam: What about copyto? It's easier to write, I think that it's not hard to understand, and perhaps it focuses less attention on the "to", making it look like a special kind of copy.

Mike: src.copy(dest, content=True, mode=False, time=False).  .copy_to is OK, .copyto is bad.  Almost everybody expects .copy to mean .copy_to and not .copy_from.

Noam: Please, what does the content/copyfile argument mean? About copymode vs. mode: I prefer copymode. "mode" seems like a mode specification (like in mkdir), not like a boolean.

= Unicode =

Noam: Someone with experience with unicode filenames, please help!

Jason:  I have some experience, not a ton.

In the Win32 API, paths are Unicode strings.  To produce a path-string you'll have to decode any non-Unicode strings in your tuple; Python's default encoding is one option, but the operating system's default encoding is another option; I think the latter is what the os functions do on Windows.

In the POSIX API, paths are char strings, which means 8-bit strings on every platform I'm familiar with.  The character set varies from system to system.  Some use UTF-8.

It's kind of squirrely if you allow both 8-bit strings and Unicode strings in your tuple.  I suggest using only Unicode within the tuple and converting to 8-bit only as needed to talk to POSIX.

Noam:

Thanks for the explanation. I agree about not mixing different kinds of strings. Is there a good way to convert unicode strings into file names on POSIX? How do you know the right encoding?

Mike: At first I thought about forcing everything to Unicode on input and adding 'encoding' and 'onerror' arguments to the constructor.  That doesn't solve the problem of chosing the charset to encode on output.  But now I'm wondering if we should just preserve whatever type(s) the user inputs.

Noam: I don't think that preserving the type of the user input will work: You'll still have to decode it to str on POSIX. It seems to me that the only solution is to use the native "alphabet" of the system: Unicode chars on Windows, and byte chars on POSIX. To put it more clearly: All elements on Windows will be unicode, all elements on POSIX will be str.

= Obsoleting other modules =

Nick:

I don't believe it's a given that a nice path object will obsolete 
the low level operations. When translating a shell script to Python (or vice versa), having access to the comparable low level operations would be of benefit.

At most, I would expect provision of an OO path API to result in a comment in the documentation of various modules (os.path, shutil, fnmatch, glob) saying that "pathlib.Path" (or whatever it ends up being called) is generally a more convenient API.

Noam:
I don't mind obsoleting os.path, shutil, fnmatch, glob, as I see them as high-level operations. I don't mind not obsoleting them either - it may keep the code more organized if different operations are in differnt modules. I agree that most of the functions in the os module shouldn't be obsoleted - these are really low-level operating system operations, and you shouldn't need to use a complex path object in order to call them.

Jason:  The new API should be the one high-level API for this type of stuff.  All the other high-level APIs should be obsoleted.

Mike: We cannot deprecate the existing functions in Python 2.x; too many existing programs would break.  But we can discourage them in the documentation.

= Additional methods/attributes =

== .purge() ==

Mike: Delete "it" recursively if it exists, whatever it is.  This is convenient when you don't care whether it's a file or directory, you just want to overwrite it, and you don't want to take six lines of code to do it.

Noam: Why six lines of code? I count four:

{{{
if p.isfile():
    p.remove()
elif p.isdir():
    p.rmtree()
}}}

We can have rmtree work also for files, and even for non-existing paths, but I'm not sure it's a good idea.
