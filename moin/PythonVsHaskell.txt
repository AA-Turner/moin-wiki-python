See also [LanguageComparisons].

== Haskell ==
Haskell is a very modern functional language. It is used for some
"real" projects (not just an experiment language) but is uncommon
in industry. More information can be found at http://www.haskell.org/.
(Please forgive or correct any errors here due to my not being very
familiar with Haskell.)

----

Haskell and Python are a somewhat odd pair to compare, because they are
so different in many ways. But what most users of both languages would
agree they DO share is a certain elegance of design.

=== Functional vs Procedural: ===
Haskell is a lazy (evaluate by need), functional (no assignments or side-effects) language. It supports parametric polymorphism (ala C++ templates), and ad-hoc polymorphism through type classes (ala Java Interfaces). Python offers the programmer 
a profusion of styles, including procedural, functional, and object-oriented. Lazy programming can be accomplished using generators and itertools.  Python
has some support for a functional style of programming, but the
profusion of side effects and the lack of tail recursion (elimination
thereof), make it an awkward style to use in Python. Haskell supports procedural programming through monads (from category theory) which are also Haskell's interface to the world of side effects (e.g. graphics, file systems, sockets, etc.). However, imperative programming is neither Haskell's intention nor strength.

=== Compiled vs Interpreted: ===
Python's primary implementation is an interpreter. Haskell has a handful of
implementations, including an interpreter (hugs) and some native-code compilers (ghc, nhc98). Haskell is a high-level language like python, so 
equal-to-C-or-asm performance should not be expected. The haskell type system,
however, does provide more compile-time information than python's does, meaning
the optimizing native-code compilers have a speed advantage over python in
many cases.

The pythonic philosophy of dropping into C for critical sections applies
equally well to haskell. Through the foreign function interface, haskell
functions can call and be called from C code. As an alternative,
compiler-specific extensions (specifically, ghc's) can be used to get closer
to the metal.

=== Static vs Dynamic Typing: ===
Both Haskell and Python have strong (not weak) typing, meaning instances
of a type cannot be cast into another type. Explicit conversions must be performed.
The difference is that Haskell has static typing,
while Python has dynamic typing. This means that in Haskell, the type of
every expression and every variable is known at compile time (and
strictly enforced), while in Python expressions and variables don't even
HAVE a type (the objects they refer to have types, but that isn't known
until runtime). Since typing is such a fundamental part of Haskell (it's
part of what makes the language easy to reason about), this difference
is a fundamental one. However, for those python users who shudder to
think of typing "int i" before every variable use, take heart: Haskell's
compilers and interpreters are smart enough to infer the types your
expressions almost all the time, so you don't have to type them. Type
inference is "static typing done right."

There is also one similarity I feel compelled to point out:

=== List Comprehension Syntax: ===
Python's list comprehension syntax is taken (with trivial
keyword/symbol modifications) directly from Haskell. The idea was just
too good to pass up.

=== Significant Whitespace: ===
Both use indentation as syntax.

=== Learning Curve: ===
Haskell has a much steeper learning curve for programmers who are not used to
functional programming. In many cases, lazy evaluation seems counterintuitive
to an imperitive-trained mind and you must unlearn techniques to prevent your
program from eating up memory.

For me (Nioate), learning ocaml first smoothed the way into haskell because ml
has a very similar (though less flexible) type system. After understanding the
type system, the jump to haskell is much less daunting: beyond new syntax, it
only involves learning to utilize lazy evaluation, type classes, and monads.
(Don't let monads scare you; learn about the list and Maybe monads first. The
[http://www.nomaware.com/monads/html/ tutorial at nomaware] is the best.)

Contributors: MichaelChermside

See also [LanguageComparisons].


== Using both Python & Haskell with ctypes (-; ==

Since, Python is the ultimate glue language, these Python vs. XLang should be replaced with Python "and" XLang. This technique works for windows and ghc:

First a test haskell program (mylib.hs):

{{{
module Mylib where

import CString

adder :: Int -> Int -> IO Int -- gratuitous use of IO
adder x y = return (x+y)

subtractor :: Int -> Int -> IO Int
subtractor x  y = return (x - y)

fact :: Int -> Int
fact n = 
    if n == 1 then 1 else (n * fact (n-1))

factorial :: Int -> IO Int
factorial n = return (fact n)


hello :: CString -> IO CString
hello w 
 = do
   s <- peekCString w       
   newCString (s ++ "World!")

mystring :: IO CString
mystring = newCString "hello world!"

foreign export stdcall adder :: Int -> Int -> IO Int
foreign export stdcall subtractor :: Int -> Int -> IO Int
foreign export stdcall factorial :: Int -> IO Int
foreign export stdcall hello :: CString -> IO CString
foreign export stdcall mystring :: IO CString
}}}

create file dllMain.c as entry point for the dll:

{{{
#include <windows.h>
#include <Rts.h>

EXTFUN (__stginit_Mylib);

static char *args[] = { "ghcDll", NULL };

/* N.B. argv arrays must end with NULL */
BOOL STDCALL DllMain (HANDLE hModule, DWORD reason, void *reserved)
{
  if (reason == DLL_PROCESS_ATTACH)
    {
/* By now, the RTS DLL should have been hoisted in, but we need to start it up. */
      startupHaskell (1, args, __stginit_Mylib);

      return TRUE;
    }
  return TRUE;
}

}}}


compile everything as so by running this batch file (build.bat):

{{{
REM test making dll
ghc -c mylib.hs -fglasgow-exts
ghc -c dllMain.c
dlltool -A -z mylib.def mylib_stub.o --export-all-symbols
ghc --mk-dll -o mylib.dll mylib.o mylib_stub.o dllMain.o -optdll-def -optdll mylib.def 

REM cleanup
rm mylib.o
rm mylib_stub.o
rm dllMain.o
rm mylib.hi
rm mylib_stub.c
rm mylib_stub.h
}}}

and then having installed ctypes, run the following python script (test_mylib.py) to test it:

{{{
#!python
from ctypes import *

lib = windll.mylib

api = {
    
#   func name     restype    argtypes
    'adder'     : (c_int,    [c_int, c_int]),
    'subtractor': (c_int,    [c_int, c_int]),
    'factorial' : (c_int,    [c_int]),
    'hello'     : (c_char_p, [c_char_p]),
    'mystring'  : (c_char_p, []),
}
        

for func in api:
    f = getattr(lib, func)
    f.restype, f.argtypes  = api[func]
    globals()[func] = f
    
print adder(1,2)
print subtractor(10,2)
print factorial(10)
print hello('hello')
print mystring()
}}}
