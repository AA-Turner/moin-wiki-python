
The {{{UnicodeEncodeError}}} normally happens when encoding a {{{unicode}}} string into a certain coding.  Since encodings map only limited number of {{{unicode}}} characters to {{{str}}} strings, a non-presented character will cause the coding-specific {{{encode()}}} to fail.

Paradoxically, a {{{UnicodeEncodeError}}} may happen when _decoding_.  The cause of it seems to be the coding-specific {{{decode()}}} functions that normally expect a parameter of type {{{str}}}.  It appears that on seeing a {{{unicode}}} parameter, the {{{decode()}}} functions "down-convert" it into {{{str}}}, then decode the result assuming it to be of their own coding.  It also appears that the "down-conversion" is performed using the {{{ASCII}}} encoder.  Hence a decoding failure inside an encoder.

The choice of the {{{ASCII}}} encoder for "down-conversion" might be considered wise because it is an intersection of all codings.  The subsequent decoding may only accept a coding-specific {{{str}}}.

However, unlike a similar issue with UnicodeDecodeError while encoding, there would be not ambiguity if {{{decode()}}} simply returned the {{{unicode}}} argument unmodified.  There seems to be not such a shortcut in {{{decode()}}} functions as of Python2.5.

{{{
#!python
>>> "a".decode("utf-8")
u'a'
>>> "\xd0\x91".decode("utf-8")
u'\u0411'
>>> u"\u0411".encode("utf-8")
'\xd0\x91'
>>> u"\u0411".decode("utf-8")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "encodings/utf_8.py", line 16, in decode
UnicodeEncodeError: 'ascii' codec can't encode character u'\u0411' in position 0: ordinal not in range(128)
>>> 
}}}
----
CategoryUnicode
