There are various fixes and improvements that should form part of a 2.0 version of Distutils.

The ultimate goal:
 * '''Must be backwards-compatible with existing setup.py scripts.'''

Other ideas:
 * Some methods may trigger PendingDeprecationWarning``s
 * Move various utility methods out of command implementations and onto the Distribution class.
 * Implement the package database described by PEP PEP:0262.
 * Consider always regenerating the MANIFEST from MANIFEST.in.
 * Finish bdist_dpkg.py
 * Use optparse instead of fancy_getopt.py, and deprecate fancy_getopt.py.
 * sdist: Include scripts, data automatically in the source distribution.
 * Drop Python 1.5.2 compatibility. Keep Python 2.0 compatiblity.
 * Improve test coverage.
 * Finish the documentation! (AnthonyBaxter has worked on a reference guide; his text is currently in [http://cvs.sourceforge.net/viewcvs.py/python/python/nondist/sandbox/distutilsref/ the CVS sandbox])
 * Package installation from PyPI (probably driven by the pythonmac-sig)
 * Add more autoconf-like tests to the config command
 * Make the design more extensible w.r.t. 'foreign' module compilation, specifically:
   * Allow the integration of autoconf/make based build systems for C/C++ extensions
   * Allow 'Extension' to be composed of components, each with their own build rules
   * Provide a means for scripts / modules to access installation parameters such as datafile directories
 * Define more default commands to build documentation, run (unit) tests, etc.

  -- StefanSeefeld

Wouldn't it be a good idea to look into [http://scons.sf.net scons] and try to let both converge as far as practical ? -- StefanSeefeld

Maybe some traditional package concepts:

 * Uninstallation.  Also getting rid of obsolete files when upgrading.
 * Dependencies.  A simple implementation might simply check to see if another library is installed and warn the user if not (and maybe install from PyPI if that feature exists).  Declaring (or worse, resolving) version dependencies or alternatives seems like overkill for now.

  -- IanBicking

   (I agree with dependency specification, but suggest dependency resolution 
   should be the responsibility of the repository/catalog and the binary package manager.)

 * Generation of multiple binary packages for a source distribution (ala Debian)
   (The Egenix tools is a good example of where this would be useful)

  -- Mark Alexander

 * Easy installation of non-python data files that are stored inside Python packages. Twisted uses this for plugins, it's also useful for storing .glade files together with the code for GTK GUI apps, etc..

  -- Itamar Shtull-Trauring

 * SciPy has some setup.py scripts that extended distutils. It may be a good idea to look there for ideas.
 * Allow MANIFEST and MANIFEST.in to be located in a directory other than the package root directory.

   -- Michiel de Hoon

 * If you use a version management system that toggles the read/write bits (e.g. perforce), distutils happily copies the mode bits when it copies files down to the build directory (etc), and then chokes when it tries to clean up after itself.  (or worse, skips important build steps so you end up with a broken release...)

  -- FredrikLundh


 * It would be great if installers generated by bdist_wininst supported a 'silent' flag for automated installs.  The silent mode would allow the package to be installed without user intervention.

  -- Phil Rittenhouse


 * bdist_wininst currently runs the 'install' command to a temporary directory, then zips up this directory, and then creates a program which will unpack the archive on the target system. It should become much smarter. Maybe only running 'build_ext' on the source system, and running the full 'install' on the target system.

 * I would also like to do much more in Python than in C in the bdist_wininst created installer. Wasn't possible in Python 1.5.2, because this didn't even have the zipfile module.

  -- Thomas Heller

 * Python packages should have a canonical way of having C/C++ headers, executable scripts, dynamic libraries (For Win32, OS X), documentation, examples, and other arbitrary data (like fonts, icons, etc.) associated with them in the same or folder (or a closely related folder with identical permissions) as the package itself.  We could use something like Apple's bundles for this purpose (sans versioning, most likely).  If a package wants to put things in places such as /usr/local/bin, they should be symlinks to what is in this new structure.

 * Multi-module installs (more than one importabl ething that goes into site-packages) should be deprecated.  If they want this behavior they should install a package and use a pth file.

 * Add the following fields to PEP PEP:0241 (PKG-INFO):  Package-Name (the actual python-importable name of what was just installed), Depends (a list of other packages, by Package-Name, that this package depends on), Recommends (a list of other packages, by Package-Name, that enhance the functionality of this package when present).  These headers make the REQUIRES and PROVIDES (how was PROVIDES useful anyways?) files from PEP PEP:0262 obsolete.

 * Perhaps a better way of finding C/C++ libraries/headers that an extension depends on, include support for OS X frameworks.  Make linking to frameworks less hackish.
  
  -- BobIppolito

 * Files that are used by a package, i.e. config and data files (possibly others), should be relocatable. 
   --Moxo

 * Why should files be relocatable when you can just make symlinks?  What would you need that for?

  -- BobIppolito
