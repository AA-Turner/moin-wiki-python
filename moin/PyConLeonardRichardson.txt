#pragma section-numbers off

= A Very Special Request =

I'd love not to have to bring my laptop to DC. If you've got a Linux laptop you're willing to lend me for the presentation, please get in touch with me (leonardr at segfault dot org).

= About Me =

Hello! I'm Leonard. This is my first conference talk. I'll keep this
page updated with information as I scramble to get the talk and the
corresponding software written in time. :)

If you're interested in me personally, you can visit [http://www.crummy.com/ my homepage].

The code in this talk is almost all code I wrote for [http://newsbruiser.tigris.org/ NewsBruiser],
a weblogging application which you might be interested in independently of the subject of this talk.

= Talk Synopsis =

Oftentimes, a very small or very new web application will keep all of
its configuration settings inside the code itself (hopefully as
variable settings in some obvious place). To change the configuration,
a user must become a developer of the application. For example:
{{{
    #Whether or not to enable image uploads
    ENABLE_IMAGE_UPLOADS = 1

    #The maximum size of an uploaded image, in kilobytes
    MAXIMUM_IMAGE_SIZE = 100
}}}
A larger, more flexible, or more mature application may keep its
configuration settings in a text file loaded by the application at
runtime. When configuring such an application a user is changing data,
rather than code, and acting as an administrator rather than a
developer. Python's ConfigParser module provides built-in support for
this level of flexibility, for example:

{{{
    [Images]
    enable-image-upload=1 #Whether or not to enable image uploads
    maximum-image-size=100 #Maximum size of an uploaded image, in kb
}}}

The natural next step towards better usability is to provide an
interface to the configuration file from within the application
itself, using the same framework and UI standards found in the rest of
the application. This allows a user to configure the application while
remaining just that--a user:

{{{
    Enable image uploads? [X]

    Maximum image size? 100___ kb

}}}


The easiest and best way to take this next step is to use a
configuration framework.

The purpose of my talk is to get more of the world's configuration
data out of configuration files and into configuration frameworks with Web interfaces. Configuration frameworks
are easier to use, can enforce configuration semantics, and don't require
shell access to the hosting machine. The framework I'll describe is
also useful for doing a user preferences engine.

My talk is currently [http://www.python.org/pycon/pycon-schedule.html scheduled]
for 11:30-12:00 on Thursday, March 27, in the Elliot room, wherever
that is. I assume there will be signs.

= Included Code =

* A full-featured configuration interface library called I Want Options (as used in NewsBruiser; you can [http://newsbruiser.tigris.org/source/browse/newsbruiser/nb/lib/IWantOptions.py view it in CVS])

* Three implementations of a silly text generation program, illustrating the "three ages of App" mentioned above.

  * An implementation which uses inline variable settings for its configuration
  * An implementation which reads its configuration from a file
  * An implementation which reads its configuration from a file, and provides a web interface to that same file through I Want Options.

* An implementation of a slightly less silly program (yet to be written) which uses I Want Options for user preferences.

= To do =

* Write the slides!

* Clean up example app #3

* Write example app that sets per-user options (context == username)

= Questions For You =

What kind of app should I write for the user preferences demonstration? I'd like at least a boolean, a selection box, and something with extra semantics (such as a date).

= Work Log =

02/27: Just wrote the same app three times. The last time was the most interesting, as I'd never before implemented a context or a configuration CGI within the framework of I Want Options. For the initial implementation (which was NewsBruiser-specific) I wrote a big blob of code, and only started splitting it out once I had to give this talk. I've now got ideas about more things I can move into IWO (an example context implementation, and some more configuration CGI logic). The other two implementations also gave me some ideas; if I changed it so that the user pass the context into the OptionConfig constructor, instead of passing it in to all the methods (which seems reasonable), I could turn getOptionValue into a __getitem__ implementation, which would be cool.

02/21: Got all the NewsBruiser-specific code out of Options.py. To celebrate, moved it out of NewsBruiser proper and into the lib/
directory. It's now a reusable library called [http://newsbruiser.tigris.org/source/browse/newsbruiser/nb/lib/IWantOptions.py I Want Options].

To get all the code moved out I had to define a plugin class (it's currently called 'wrapper', but that doesn't make much sense) which contains application-specific code and is passed into the OptionGroup and Option constructors. It basically simulates a superclass of all the Option classes, so that you can change the generic Option behavior without having to change all the Option classes to subclass a different class. There might be a design pattern that describes this which would make renaming it easy. Or it might just be an OO hack, in which case I'll probably call it "Implementation" or "ImplementationDetails".

02/19: Yesterday I worked on cleaning up Options.py: moving out NewsBruiserisms, adding comments and PyDoc. 
I tell myself that this is useful work for the talk and not just a heavily disguised method of procrastination.
Today: more of the same. Also set up this wiki page.


----
CategoryPyConSpeakerPage
