The [[http://cppyy.readthedocs.io|cppyy]] package integrates the Clang/LLVM-based [[https://github.com/vgvassilev/cling|Cling C++ interpreter]] into Python, providing interactive access to C/C++ from Python. Using precompiled modules, a class loader, and an everything-lazy implementation, cppyy is designed for automatically binding large scale C++ programs. PyPy supports cppyy natively for high performance, as described in this [[http://wlav.web.cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf|PyHPC'16]] paper.

Thanks to LLVM's JIT, cppyy supports embedded C++ code, automatic template instantiations, auto-downcasting, etc., etc. Where possible, C++ idioms are automatically recognized and pythonized. If necessary, a pythonization API provides further fine tuning for memory ownership, threading, and application-specific conversions. Example:
{{{#!highlight python
>>> import cppyy
>>> cppyy.cppdef("""
... class MyClass {
... public:
...     MyClass(int i) : m_data(i) {}
...     int m_data;
... };""")                               # defines a new C++ class
>>> from cppyy.gbl import MyClass        # bound on-the-fly
>>> v = cppyy.gbl.std.vector[MyClass]()  # template generated
>>> v += [MyClass(i) for i in range(3)]
>>> len(v)
3
>>> for m in v:                          # idiomatically mapped
...    print(m.m_data)
...
0
1
2
# create a C++ function on the fly and attach on the Python side
>>> cppyy.cppdef("auto add_int = [](MyClass* m, int a) { return m->m_data + a; };")
>>> MyClass.add_int = lambda self, i: cppyy.gbl.add_int(self, i)
>>> for m in v:
...    print(m.add_int(1))
... 
1
2
3
>>>
}}}

Full details in the cppyy documentation: [[http://cppyy.readthedocs.io]]
