This page documents the time-complexity of various operations in current CPython.  Other Python implementations (or older or still-under development versions of CPython) may have slightly different performance characteristics.  However, it is generally safe to assume that they are not slower by more than a factor of O(log n).

Generally, 'n' is the number of elements currently in the container.  'k' is either the value of a parameter or the number of elements in the parameter.

= list =
The Average Case assumes parameters generated uniformly at random.

Internally, a list is represented as an array; the largest costs come from growing beyond the current allocation size (because everything must move), or from inserting or deleting somewhere near the beginning (because everything after that must move).  If you need to add/remove at both ends, consider using a collections.deque instead.
||<tablewidth="" tablestyle="">'''Operation''' ||'''Average Case''' ||'''[http://en.wikipedia.org/wiki/Amortized_analysis Amortized Worst Case]''' ||
||Copy ||O(n) ||O(n) ||
||Append[1] ||O(1) ||O(1) ||
||Insert ||O(n) ||O(n) ||
||Get Item ||O(1) ||O(1) ||
||Set Item ||O(1) ||O(1) ||
||Delete Item ||O(n) ||O(n) ||
||Iteration ||O(n) ||O(n) ||
||Get Slice ||O(k) ||O(k) ||
||Del Slice ||O(n) ||O(n) ||
||Set Slice ||O(k+n) ||O(k+n) ||
||Extend ||O(k) ||O(k) ||
||[http://svn.python.org/projects/python/trunk/Objects/listsort.txt Sort] ||O(n log n) ||O(n log n) ||
||Multiply ||O(nk) ||O(nk) ||
||x in s||O(n)||||
||min(s), max(s)||O(n)||||


= collections.deque =
A deque (double-ended queue) is represented internally as a doubly linked list.  (Well, a list of arrays rather than objects, for greater efficiency.)  Both ends are accessible, but even looking at the middle is slow, and adding to or removing from the middle is slower still.
||<tablewidth="" tablestyle="">'''Operation''' ||'''Average Case''' ||'''Amortized Worst Case''' ||
||Copy ||O(n) ||O(n) ||
||append ||O(1) ||O(1) ||
||appendleft ||O(1) ||O(1) ||
||pop ||O(1) ||O(1) ||
||popleft ||O(1) ||O(1) ||
||extend ||O(k) ||O(k) ||
||extendleft ||O(k) ||O(k) ||
||rotate ||O(k) ||O(k) ||
||remove ||O(n) ||O(n) ||


= set =
See dict -- the implementation is intentionally very similar.
||'''Operation'''||'''Average case'''||'''Worst Case'''||
||x in s||O(1)||O(n)||
||Union s|t||?||||
||Intersection s&t||?||||
||Difference s-t||O(len(s))||||
||s.difference(t)||O(len(t))||||
||Symmetric Difference s^t||?||||


= dict =
The Average Case times listed for dict objects assume that the hash function for the objects is sufficiently robust to make collisions uncommon.  The Average Case assumes the keys used in parameters are selected uniformly at random from the set of all keys.

Note that there is a fast-path for dicts that (in practice) only deal with str keys; this doens't affect the algorithmic complexity, but it can significantly affect the constant factors: how quickly a typical program finishes.
||<tablewidth="" tablestyle="">'''Operation''' ||'''Average Case''' ||'''Amortized Worst Case''' ||
||Copy[2] ||O(n) ||O(n) ||
||Get Item ||O(1) ||O(n) ||
||Set Item[1] ||O(1) ||O(n) ||
||Delete Item ||O(1) ||O(n) ||
||Iteration[2] ||O(n) ||O(n) ||


= Notes =
[1] = These operations rely on the "Amortized" part of "Amortized Worst Case".  Individual actions may take surprisingly long, depending on the history of the container.

[2] = For these operations, the worst case ''n'' is the maximum size the container ever achieved, rather than just the current size.  For example, if N objects are added to a dictionary, then N-1 are deleted, the dictionary will still be sized for N objects (at least) until another insertion is made.
