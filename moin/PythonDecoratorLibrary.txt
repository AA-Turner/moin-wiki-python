'''This page is meant to be a central repository of decorator code pieces''', whether useful or not <wink>.
It is NOT a page to discuss decorator syntax!

Feel free to add your suggestions (please use the current decorator syntax @dec)!

[[TableOfContents()]]


== Creating Well-Behaved Decorators / "Decorator decorator" ==

Note:  This is only one recipe.  Others include inheritance
from a standard decorator (link?) and a factory function
such as [http://www.phyast.pitt.edu/~micheles/python/decorator.zip Michele Simionato's decorator module] which even preserves signature information.

{{{
#!python
def simple_decorator(decorator):
    """This decorator can be used to turn simple functions
    into well-behaved decorators, so long as the decorators
    are fairly simple. If a decorator expects a function and
    returns a function (no descriptors), and if it doesn't
    modify function attributes or docstring, then it is
    eligible to use this. Simply apply @simple_decorator to
    your decorator and it will automatically preserve the
    docstring and function attributes of functions to which
    it is applied."""
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    # Now a few lines needed to make simple_decorator itself
    # be a well-behaved decorator.
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator

#
# Sample Use:
#
@simple_decorator
def mySimpleLoggingDecorator( func ):
    def YOU_WILL_NEVER_SEE_THIS_NAME( *args, **kwargs ):
        print 'calling %s' % func.__name__
        return func( *args, **kwargs )
    return YOU_WILL_NEVER_SEE_THIS_NAME

@mySimpleLoggingDecorator
def double(x):
    "Doubles a number"
    return 2*x

assert double.__name__ == 'double'
assert double.__doc__ == 'Doubles a number'
print double(155)
}}}

== Property Definition ==

These decorators provide a readable way to define properties:

{{{
#!python
import sys

def propget(func):
    locals = sys._getframe(1).f_locals
    name = func.__name__
    prop = locals.get(name)
    if not isinstance(prop, property):
        prop = property(func, doc=func.__doc__)
    else:
        doc = prop.__doc__ or func.__doc__
        prop = property(func, prop.fset, prop.fdel, doc)
    return prop

def propset(func):
    locals = sys._getframe(1).f_locals
    name = func.__name__
    prop = locals.get(name)
    if not isinstance(prop, property):
        prop = property(None, func, doc=func.__doc__)
    else:
        doc = prop.__doc__ or func.__doc__
        prop = property(prop.fget, func, prop.fdel, doc)
    return prop

def propdel(func):
    locals = sys._getframe(1).f_locals
    name = func.__name__
    prop = locals.get(name)
    if not isinstance(prop, property):
        prop = property(None, None, func, doc=func.__doc__)
    else:
        prop = property(prop.fget, prop.fset, func, prop.__doc__)
    return prop

# These can be used like this:

class Example(object):

    @propget
    def myattr(self):
        return self._half * 2

    @propset
    def myattr(self, value):
        self._half = value / 2

    @propdel
    def myattr(self):
        del self._half
}}}


Here's a way that doesn't require any new decorators:

{{{
#!python
class Example(object):
    @apply
    def myattr():
        doc = """This is the doc string."""

        def fget(self):
            return self._half * 2

        def fset(self, value):
            self._half = value / 2

        def fdel(self):
            del self._half

        return property(**locals())
}}}

Yet another property decorator:

{{{
#!python
def Property(function):
    keys = 'fget', 'fset', 'fdel'
    func_locals = {'doc':function.__doc__}
    def probeFunc(frame, event, arg):
        if event == 'return':
            locals = frame.f_locals
            func_locals.update(dict((k,locals.get(k)) for k in keys))
            sys.settrace(None)
        return probeFunc
    sys.settrace(probeFunc)
    function()
    return property(**func_locals)

#====== Example =======================================================

from math import radians, degrees, pi

class Angle(object):
    def __init__(self,rad):
        self._rad = rad

    @Property
    def rad():
        '''The angle in radians'''
        def fget(self):
            return self._rad
        def fset(self,angle):
            if isinstance(angle,Angle): angle = angle.rad
            self._rad = float(angle)

    @Property
    def deg():
        '''The angle in degrees'''
        def fget(self):
            return degrees(self._rad)
        def fset(self,angle):
            if isinstance(angle,Angle): angle = angle.deg
            self._rad = radians(angle)
}}}

== Memoize ==

Here's a memoizing class.

{{{
#!python
class memoized(object):
   """Decorator that caches a function's return value each time it is called.
   If called later with the same arguments, the cached value is returned, and
   not re-evaluated.
   """
   def __init__(self, func):
      self.func = func
      self.cache = {}
   def __call__(self, *args):
      try:
         return self.cache[args]
      except KeyError:
         self.cache[args] = value = self.func(*args)
         return value
      except TypeError:
         # uncachable -- for instance, passing a list as an argument.
         # Better to not cache than to blow up entirely.
         return self.func(*args)
   def __repr__(self):
      """Return the function's docstring."""
      return self.func.__doc__

@memoized
def fibonacci(n):
   "Return the nth fibonacci number."
   if n in (0, 1):
      return n
   return fibonacci(n-1) + fibonacci(n-2)

print fibonacci(12)
}}}

== Pseudo-currying ==

{{{
#!python
class curried(object):
  """
  Decorator that returns a function that keeps returning functions
  until all arguments are supplied; then the original function is
  evaluated.
  """

  def __init__(self, func, *a):
    self.func = func
    self.args = a
  def __call__(self, *a):
    args = self.args + a
    if len(args) < self.func.func_code.co_argcount:
      return curried(self.func, *args)
    else:
      return self.func(*args)


@curried
def add(a, b):
    return a+b

add1 = add(1)

print add1(2)

}}}

== Controllable DIY debug ==

(Other hooks could be similarly added. Docstrings and exceptions are left out for simplicity
of demonstration.)

{{{
#!python
import sys

WHAT_TO_DEBUG = set(['io', 'core'])  # change to what you need

class debug:
    """ Decorator which helps to control what aspects of a program to debug
    on per-function basis. Aspects are provided as list of arguments.
    It DOESN'T slowdown functions which aren't supposed to be debugged.
    """
    def __init__(self, aspects=None):
        self.aspects = set(aspects)

    def __call__(self, f):
        if self.aspects & WHAT_TO_DEBUG:
            def newf(*args, **kwds):
                print >> sys.stderr, f.func_name, args, kwds
                f_result = f(*args, **kwds)
                print >> sys.stderr, f.func_name, "returned", f_result
                return f_result
            newf.__doc__ = f.__doc__
            return newf
        else:
            return f

@debug(['io'])
def prn(x):
    print x

@debug(['core'])
def mult(x, y):
    return x * y

prn(mult(2,2))

}}}

== Easy adding methods to a class instance ==

Credits to John Roth.

{{{
#!python
class Foo:
    def __init__(self):
        self.x = 42

foo = Foo()

def addto(instance):
    def decorator(f):
        import new
        f = new.instancemethod(f, instance, instance.__class__)
        setattr(instance, f.func_name, f)
        return f
    return decorator

@addto(foo)
def print_x(self):
    print self.x

# foo.print_x() would print "42"
}}}

== Counting function calls ==

{{{
#!python
class countcalls(object):
   "Decorator that keeps track of the number of times a function is called."

   __instances = {}

   def __init__(self, f):
      self.__f = f
      self.__numCalls = 0
      countcalls.__instances[f] = self

   def __call__(self, *args, **kwargs):
      self.__numCalls += 1
      return self.__f(*args, **kwargs)

   @staticmethod
   def count(f):
      "Return the number of times the function f was called."
      return countcalls.__instances[f].__numCalls

   @staticmethod
   def counts():
      "Return a dict of {function: # of calls} for all registered functions."
      return dict([(f, countcalls.count(f)) for f in countcalls.__instances])
}}}

== Generating Deprecation Warnings ==

{{{
#!python
import warnings

def deprecated(func):
    """This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted
    when the function is used."""
    def newFunc(*args, **kwargs):
        warnings.warn("Call to deprecated function %s." % func.__name__,
                      category=DeprecationWarning)
        return func(*args, **kwargs)
    newFunc.__name__ = func.__name__
    newFunc.__doc__ = func.__doc__
    newFunc.__dict__.update(func.__dict__)
    return newFunc

# === Examples of use ===

@deprecated
def some_old_function(x,y):
    return x + y

class SomeClass:
    @deprecated
    def some_old_method(self, x,y):
        return x + y
}}}

== Enable/Disable Decorators ==

{{{
#!python
def unchanged(func):
    "This decorator doesn't add any behavior"
    return func

def disabled(func):
    "This decorator disables the provided function, and does nothing"
    def emptyFunc(*args,**kargs):
        pass
    return emptyFunc

# define this as equivalent to unchanged, for nice symmetry with disabled
enabled = unchanged

#
# Sample use
#

globalEnableFlag = int(True)

state = (disabled, enabled)[globalEnableFlag]
@state
def specialFunctionFoo():
    print "function was enabled"
}}}


== Easy Dump of Function Arguments ==

{{{
#!python
def dumpArgs(func):
    "This decorator dumps out the arguments passed to a function before calling it"
    argnames = func.func_code.co_varnames[:func.func_code.co_argcount]
    fname = func.func_name
    def echoFunc(*args,**kwargs):
        print fname, ":", ', '.join('%s=%r' % entry
                                    for entry in zip(argnames,args) + kwargs.items())
        return func(*args, **kwargs)
    return echoFunc

@dumpArgs
def f1(a,b,c):
    print a + b + c

f1(1, 2, 3)
}}}


== Pre-/Post-Conditions ==

{{{
#!python
"""
Provide pre-/postconditions as function decorators.

Example usage:

  >>> def in_ge20(inval):
  ...    assert inval >= 20, 'Input value < 20'
  ...
  >>> def out_lt30(retval, inval):
  ...    assert retval < 30, 'Return value >= 30'
  ...
  >>> @precondition(in_ge20)
  ... @postcondition(out_lt30)
  ... def inc(value):
  ...   return value + 1
  ...
  >>> inc(5)
  Traceback (most recent call last):
    ...
  AssertionError: Input value < 20
  >>> inc(29)
  Traceback (most recent call last):
    ...
  AssertionError: Return value >= 30
  >>> inc(20)
  21

You can define as many pre-/postconditions for a function as you
like. It is also possible to specify both types of conditions at once:

  >>> @conditions(in_ge20, out_lt30)
  ... def add1(value):
  ...   return value + 1
  ...
  >>> add1(5)
  Traceback (most recent call last):
    ...
  AssertionError: Input value < 20

An interesting feature is the ability to prevent the creation of
pre-/postconditions at function definition time. This makes it
possible to use conditions for debugging and then switch them off for
distribution.

  >>> debug = False
  >>> @precondition(in_ge20, debug)
  ... def dec(value):
  ...   return value - 1
  ...
  >>> dec(5)
  4
"""

__all__ = [ 'precondition', 'postcondition', 'conditions' ]

DEFAULT_ON = True

def precondition(precondition, use_conditions=DEFAULT_ON):
    return conditions(precondition, None, use_conditions)

def postcondition(postcondition, use_conditions=DEFAULT_ON):
    return conditions(None, postcondition, use_conditions)

class conditions(object):
    __slots__ = ('__precondition', '__postcondition')

    def __init__(self, pre, post, use_conditions=DEFAULT_ON):
        if not use_conditions:
            pre, post = None, None

        self.__precondition  = pre
        self.__postcondition = post

    def __call__(self, function):
        # combine recursive wrappers (@precondition + @postcondition == @conditions)
        pres  = set( (self.__precondition,) )
        posts = set( (self.__postcondition,) )

        # unwrap function, collect distinct pre-/post conditions
        while type(function) is FunctionWrapper:
            pres.add(function._pre)
            posts.add(function._post)
            function = function._func

        # filter out None conditions and build pairs of pre- and postconditions
        conditions = map(None, filter(None, pres), filter(None, posts))

        # add a wrapper for each pair (note that 'conditions' may be empty)
        for pre, post in conditions:
            function = FunctionWrapper(pre, post, function)

        return function

class FunctionWrapper(object):
    def __init__(self, precondition, postcondition, function):
        self._pre  = precondition
        self._post = postcondition
        self._func = function

    def __call__(self, *args, **kwargs):
        precondition  = self._pre
        postcondition = self._post

        if precondition:
            precondition(*args, **kwargs)
        result = self._func(*args, **kwargs)
        if postcondition:
            postcondition(result, *args, **kwargs)
        return result

def __test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    __test()
}}}

== Profiling/Coverage Analysis ==

The code and examples are a bit longish, so I'll include a link instead:
http://mg.pov.lt/blog/profiling.html

== Line Tracing Individual Functions ==

I cobbled this together from the trace module.  It allows you to decorate
individual functions so their lines are traced.  I think it works out to
be a slightly smaller hammer than running the trace module and trying to
pare back what it traces using exclusions.

{{{
#!python
import sys
import os
import linecache

def trace(f):
    def globaltrace(frame, why, arg):
        if why == "call":
            return localtrace
        return None

    def localtrace(frame, why, arg):
        if why == "line":
            # record the file name and line number of every trace
            filename = frame.f_code.co_filename
            lineno = frame.f_lineno

            bname = os.path.basename(filename)
            print "%s(%d): %s" % (bname, lineno,
                                  linecache.getline(filename, lineno)),
        return localtrace

    def _f(*args, **kwds):
        sys.settrace(globaltrace)
        result = f(*args, **kwds)
        sys.settrace(None)
        return result

    return _f
}}}

== Synchronization ==

Synchronize two (or more) functions on a given lock.

{{{
#!python
def synchronized(lock):
    """ Synchronization decorator. """

    def wrap(f):
        def newFunction(*args, **kw):
            lock.acquire()
            try:
                return f(*args, **kw)
            finally:
                lock.release()
        return newFunction
    return wrap

# Example usage:

from threading import Lock
myLock = Lock()

@synchronized(myLock)
def critical1(*args):
    # Interesting stuff goes here.
    pass

@synchronized(myLock)
def critical2(*args):
    # Other interesting stuff goes here.
    pass
}}}

== Type Enforcement (accepts/returns) ==

Provides various degrees of type enforcement for function parameters and return values.

{{{
#!python
"""
One of three degrees of enforcement may be specified by passing
the 'debug' keyword argument to the decorator:
    0 -- NONE:   No type-checking. Decorators disabled.
    1 -- MEDIUM: Print warning message to stderr. (Default)
    2 -- STRONG: Raise TypeError with message.
If 'debug' is not passed to the decorator, the default level is used.

Example usage:
    >>> NONE, MEDIUM, STRONG = 0, 1, 2
    >>>
    >>> @accepts(int, int, int)
    ... @returns(float)
    ... def average(x, y, z):
    ...     return (x + y + z) / 2
    ...
    >>> average(5.5, 10, 15.0)
    TypeWarning:  'average' method accepts (int, int, int), but was given
    (float, int, float)
    15.25
    >>> average(5, 10, 15)
    TypeWarning:  'average' method returns (float), but result is (int)
    15

Needed to cast params as floats in function def (or simply divide by 2.0).

    >>> TYPE_CHECK = STRONG
    >>> @accepts(int, debug=TYPE_CHECK)
    ... @returns(int, debug=TYPE_CHECK)
    ... def fib(n):
    ...     if n in (0, 1): return n
    ...     return fib(n-1) + fib(n-2)
    ...
    >>> fib(5.3)
    Traceback (most recent call last):
      ...
    TypeError: 'fib' method accepts (int), but was given (float)

"""
import sys

def accepts(*types, **kw):
    """ Function decorator. Checks that inputs given to decorated function
    are of the expected type.

    Parameters:
    types -- The expected types of the inputs to the decorated function.
             Must specify type for each parameter.
    kw    -- Optional specification of 'debug' level (this is the only valid
             keyword argument, no other should be given).
             debug=( 0 | 1 | 2 )

    """
    if not kw:
        # default level: MEDIUM
        debug = 1
    else:
        debug = kw['debug']
    try:
        def decorator(f):
            def newf(*args):
                if debug == 0:
                    return f(*args)
                assert len(args) == len(types)
                argtypes = tuple(map(type, args))
                if argtypes != types:
                    msg = info(f.__name__, types, argtypes, 0)
                    if debug == 1:
                        print >> sys.stderr, 'TypeWarning: ', msg
                    elif debug == 2:
                        raise TypeError, msg
                return f(*args)
            newf.__name__ = f.__name__
            return newf
        return decorator
    except KeyError, key:
        raise KeyError, key + "is not a valid keyword argument"
    except TypeError, msg:
        raise TypeError, msg


def returns(ret_type, **kw):
    """ Function decorator. Checks that return value of decorated function
    is of the expected type.

    Parameters:
    ret_type -- The expected type of the decorated function's return value.
                Must specify type for each parameter.
    kw       -- Optional specification of 'debug' level (this is the only valid
                keyword argument, no other should be given).
                debug=( 0 | 1 | 2 )

    """
    try:
        if not kw:
            # default level: MEDIUM
            debug = 1
        else:
            debug = kw['debug']
        def decorator(f):
            def newf(*args):
                result = f(*args)
                if debug == 0:
                    return result
                res_type = type(result)
                if res_type != ret_type:
                    msg = info(f.__name__, (ret_type,), (res_type,), 1)
                    if debug == 1:
                        print >> sys.stderr, 'TypeWarning: ', msg
                    elif debug == 2:
                        raise TypeError, msg
                return result
            newf.__name__ = f.__name__
            return newf
        return decorator
    except KeyError, key:
        raise KeyError, key + "is not a valid keyword argument"
    except TypeError, msg:
        raise TypeError, msg

def info(fname, expected, actual, flag):
    """ Convenience function returns nicely formatted error/warning msg. """
    format = lambda types: ', '.join([str(t).split("'")[1] for t in types])
    expected, actual = format(expected), format(actual)
    msg = "'%s' method " % fname \
          + ("accepts", "returns")[flag] + " (%s), but " % expected\
          + ("was given", "result is")[flag] + " (%s)" % actual
    return msg
}}}



== CGI method wrapper ==

Handles HTML boilerplate at top and bottom of pages returned from CGI methods.  Works with the cgi module.  Now your request handlers can just output the interesting HTML, and let the decorator deal with all the top and bottom clutter.

(Note: the exception handler eats all exceptions, which in CGI is no big loss, since the program runs in its separate subprocess.  At least here, the exception contents will be written to the output page.)

{{{
#!python
class CGImethod(object):
    def __init__(self,title):
        self.title = title
    def __call__(self,fn):
        def wrappedFn(*args):
            print "Content-Type: text/html\n\n"
            print "<HTML>"
            print "<HEAD><TITLE>%s</TITLE></HEAD>" % self.title
            print "<BODY>"
            try:
                fn(*args)
            except Exception,e:
                print
                print e
            print
            print "</BODY></HTML>"

        return wrappedFn

@CGImethod("Hello with Decorator")
def sayHello():
    print '<h1>Hello from CGI-Land</h1>'

}}}
== State Machine Implementaion ==

This example uses Decorators to facilitate the implementation of a
state machine in Python.  Decorators are used to specify which methods
are the event handlers for the class.  In this example, actions are
associated with the transitions, but it is possible with a little
consideration to associate actions with states instead. 

The example defines a class, myMachine that is a state machine. 
Multiple instances of the class may be instantiated with each maintaining its own state. A class also may have multiple states.
Here I've used Gstate and Tstate.  

The code in the imported stateDefn file gets a bit hairy, but
you may not need to delve into it for your application.

{{{
# State Machine example Program

from StateDefn import *

class MyMachine(object):

    # Create Statedefn object for each state you need to keep track of.
    # the name passed to the constructor becomes a StateVar member of the current class.
    # i.e. if myObj is a MyMachine object, myObj.gstate maintains the current Gstate
    Gstate = StateTable("gstate")
    Tstate = StateTable("turtle")

    def __init__(self, name):
        # must call init method of class's StateTable object. to initialize state variable
        self.Gstate.initialize(self)
        self.Tstate.initialize(self)
        self.mname = name
        self.Acount = 0
        self.Bcount = 0
        self.Ccount = 0

    # Decorate the Event Handler virtual functions -note Gstate parameter
    @EventHandler(Gstate)
    def EventA( self ): pass
    @EventHandler(Gstate)
    def EventB( self ): pass
    @EventHandler(Gstate)
    def EventC( self, val ): pass

    @EventHandler(Tstate)
    def Toggle(self): pass


    # define methods to handle events.
    def _eventAHdlr1(self):
        print "State 1, event A"
        self.Acount += 1
    def _eventBHdlr1(self):
        print "State 1, event B"
        self.Bcount += 1
    def _eventCHdlr1(self, val):
        print "State 1, event C"
        self.Ccount += 3*val

    def _eventAHdlr2(self):
        print "State 2, event A"
        self.Acount += 10
        # here we brute force the Tstate to on, leave & enter functions called if state changes.
        # turtle is object's state variable for Tstate, comes from constructor argument
        self.turtle.SetState(self, self._t_on )
    def _eventBHdlr2(self):
        print "State 2, event B"
        self.Bcount += 10
    def _eventCHdlr2(self, val):
        print "State 2, event C"
        self.Ccount += 2*val

    def _eventAHdlr3(self):
        self.Acount += 100
        print "State 3, event A"
    def _eventBHdlr3(self):
        print "State 3, event B"
        self.Bcount += 100
        # we decide here we want to go to state 2, overrrides spec in state table below.
        # transition to NextState is made after the method exits.
        self.gstate.NextState = self._state2 
    def _eventCHdlr3(self, val):
        print "State 3, event C"
        self.Ccount += 5*val
    
    # Associate the handlers with a state. The first argument is a list of methods.
    # One method for each EventHandler decorated function of Gstate. Order of methods
    # in the list correspond to order in which the Event Handlers were declared.
    # Second arg is the name of the state.  Third argument is to be come a list of the
    # next states. 
    # The first state created becomes the initial state.
    _state1 = Gstate.State("One",  (_eventAHdlr1, _eventBHdlr1, _eventCHdlr1 ), 
                                      ("Two", "Three", None ))
    _state2 = Gstate.State("Two",  (_eventAHdlr2, _eventBHdlr2, _eventCHdlr2 ),
                                     ("Three",        None,          "One"))
    _state3 = Gstate.State("Three",(_eventAHdlr3, _eventBHdlr3, _eventCHdlr3 ),
                                 (None,         "One",         "Two"))


    # Declare a function that will be called when entering a new Gstate.
    # Can also declare a leave function using @OnLeaveFunction(Gstate)
    @OnEnterFunction(Gstate)
    def _enterGstate(self):
        print "entering state ", self.gstate.Name() , "of ", self.mname
    @OnLeaveFunction(Tstate)
    def _leaveTstate(self):
        print "leaving state ", self.turtle.Name() , "of ", self.mname


    def _toggleOn(self):
        print "Toggle On"

    def _toggleOff(self):
        print "Toggle Off"

    _t_off = Tstate.State( "Off", [_toggleOn],
                         ["On"     ])
    _t_on =  Tstate.State( "On",  [_toggleOff],
                          ["Off"])


def main():
    bigMachine = MyMachine("big")
    lilMachine = MyMachine("lil")

    bigMachine.EventA()
    lilMachine.EventA()
    bigMachine.EventA()
    lilMachine.EventA()
    bigMachine.EventB()
    lilMachine.EventB()
    bigMachine.EventC(4)
    lilMachine.EventC(2)
    bigMachine.EventC(1)
    lilMachine.EventC(3)
    bigMachine.EventB()
    lilMachine.EventB()
    bigMachine.EventA()
    lilMachine.EventA()
    bigMachine.EventA()

    bigMachine.Toggle()
    bigMachine.Toggle()
    bigMachine.Toggle()

    lilMachine.EventA()
    bigMachine.EventB()
    lilMachine.EventB()
    bigMachine.EventC(3)
    bigMachine.EventA()
    lilMachine.EventC(2)
    lilMachine.EventA()
    bigMachine.EventB()
    lilMachine.EventB()
    bigMachine.EventC(7)
    lilMachine.EventC(1)

    print "Event A count ", bigMachine.Acount
    print "Event B count ", bigMachine.Bcount
    print "Event C count ", bigMachine.Ccount
    print "LilMachine C count ", lilMachine.Ccount

main()

}}}
And now the imported StateDefn.py
{{{
#
# Support for State Machines.  ref - Design Patterns by GoF
#  Many of the methods in these classes get called behind the scenes. 
#
#  Notable exceptions are methods of the StateVar class. 
#
#  See example programs for how this module is intended to be used.
#
import exceptions

class StateMachineError( exceptions.Exception):
    def __init__(self, args = None):
       self.args = args

class StateVar(object):
    def __init__(self, initialState):
        self._currentState = initialState
        self.NextState = initialState            # publicly settable in an event handling routine.
    
    def SetState( self, owner, newState):
        '''
        Forces a state change to newState
        '''
        self.NextState = newState
        self.__toNextState( owner )

    def __toNextState(self, owner):
        '''
        The low-level state change function which calls leave state & enter state functions as 
        needed.

        LeaveState and EnterState functions are called as needed when state transitions.
        '''
        if not (self.NextState is self._currentState):
            if ( hasattr( self._currentState, "leave")):
                leave = self._currentState.leave
                leave(owner)
            elif (hasattr( self, "leave")):
                 self.leave(owner)
            self._currentState =  self.NextState
            if ( hasattr( self._currentState, "enter")):
                enter = self._currentState.enter
                enter(owner)
            elif (hasattr( self, "enter")):
                self.enter(owner)

    def __fctn( self, funcName ):
        ''' 
        Returns the owning class's method for handling an event for the current state.
        This method not for public consumption.
        '''
        vf = self._currentState.GetFE(funcName)
        return vf

    def Name(self):
        '''
        Returns the current state name.
        '''
        return self._currentState.name

class STState(object):
    def __init__(self, stateName):
        self.name = stateName
        self.fctnDict = {}

    def SetEvents( self, eventList, eventHdlrList, nextStates ):
        dictionary = self.fctnDict
        if not nextStates:
            def setRow( event, method ):
                dictionary[ event ] = [method, None]
            map( setRow, eventList, eventHdlrList)
        else:
            def setRow2( event, method, nextState ):
                dictionary[ event ] = [method, nextState]
            map( setRow2, eventList, eventHdlrList, nextStates)
        self.fctnDict = dictionary

    def GetFE( self, fctnName):
        return self.fctnDict[fctnName]

    def MapNextStates(self, stateDict):
        ''' Changes second dict value from name of state to actual state '''
        for de in self.fctnDict.values():
            nextStateName = de[1]
            if nextStateName:
                if stateDict.has_key( nextStateName ):
                    de[1] = stateDict[nextStateName]
                else:
                    raise StateMachineError( 'Invalid Name for next state: %s' % nextStateName )


class StateTable(object):
    '''
    Magical class to define a state machine, with the help of several decorator functions
    which follow.
    '''
    def __init__( self, declname):
        self.machineVar=declname
        self._initialState = None
        self._stateList = {}
        self._eventList = []
        self.needInitialize = 1
    
    def initialize(self, parent):
        '''
        Initializes the parent class's state variable for this StateTable class. 
        Must call this method in the parent' object's __init__ method.  You can have
        Multiple state machines within a parent class. Call this method for each
        '''
        statevar= StateVar( self._initialState)
        parent.__dict__[self.machineVar] =statevar
        if (hasattr( self, "enter")):
            statevar.enter = self.enter
        if (hasattr( self, "leave")):
            statevar.leave = self.leave
        #Magic happens here - in the 'next state' table, translate names into state objects.
        if  self.needInitialize:
            for xstate in list(self._stateList.values()):
                xstate.MapNextStates( self._stateList )
            self.needInitialize = 0

    def DefState( self, eventHdlrList, name ) :
        '''
        This is used to define a state. the event handler list is a list of functions that
        are called for corresponding events. name is the name of the state.
        '''
        stateTableRow = STState(name)
        if ( len(eventHdlrList) != len(self._eventList)):
            raise StateMachineError('Mismatch between number of event handlers and the methods specified for the state.')

        stateTableRow.SetEvents( self._eventList, eventHdlrList, None )
        
        if self._initialState is None:
            self._initialState = stateTableRow
        self._stateList[name] = stateTableRow
        return stateTableRow

    def State( self, name, eventHdlrList, nextStates ) :
        stateTableRow = STState(name)
        if ( len(eventHdlrList) != len(self._eventList)):
            raise StateMachineError('Mismatch between number of event handlers and the methods specified for the state.')
        if ( (not nextStates is None) and len(nextStates) != len(self._eventList)):
            raise StateMachineError('Mismatch between number of event handlers and the next states specified for the state.')
        
        stateTableRow.SetEvents( self._eventList, eventHdlrList, nextStates )
        
        if self._initialState is None:
            self._initialState = stateTableRow
        self._stateList[name] = stateTableRow
        return stateTableRow

    def __AddEvHdlr( self, funcName ):
        '''
        Informs the class of an event handler to be added. We just need the name here. The
        function name will later be associated with one of the functions in a list when a state is defined.
        '''
        self._eventList.append( funcName )

# Decorator functions ... 
def EventHandler( stateClass ):
    '''
    Declare a method that handles a type of event.
    '''
    def Wrapper( func ):
        stateClass._StateTable__AddEvHdlr( func.__name__ )
        def ObjCall( self, *args, **keywords ):
            stateVar = self.__dict__[ stateClass.machineVar ]
            funky, nextState = stateVar._StateVar__fctn( func.__name__ )
            if not nextState is None:
                stateVar.NextState = nextState
            rv = funky(self, *args, **keywords )
            stateVar._StateVar__toNextState( self)
            return rv
        return ObjCall
    return Wrapper

def OnEnterFunction( stateClass ):
    '''
    Declare that this method should be called whenever a new state is entered.
    '''
    def Wrapper(func):
        stateClass.enter = func
        return func
    return Wrapper

def OnLeaveFunction( stateClass ):
    '''
    Declares that this method should be called whenever leaving a state.
    '''
    def Wrapper(func):
        stateClass.leave = func
        return func
    return Wrapper

}}}
