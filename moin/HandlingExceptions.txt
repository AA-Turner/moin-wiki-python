= Handling Exceptions =

= Manutenere le Eccezioni =

The simplest way to handle exceptions is with a "try-except" block:

{{{
#!python
(x,y) = (5,0)
try:
  z = x/y
except ZeroDivisionError:
  print "divide by zero"
}}}

If you wanted to examine the exception from code, you could have:

{{{
#!python
(x,y) = (5,0)
try:
  z = x/y
except ZeroDivisionError, e:
  z = e # representation: "<exceptions.ZeroDivisionError instance at 0x817426c>"
print z # output: "integer division or modulo by zero"
}}}

== General Error Catching ==

Sometimes, you want to catch ''all'' errors that could possibly be generated, but usually ''you don't''.In most cases, you want to be as specific as possible (Wiki:CatchWhatYouCanHandle). In the first example above, if you were using a catch-all exception clause and a user presses Ctrl-C, generating a KeyboardInterrupt, you don't want the program to print "divide by zero".

However, there are some situations where it's best to catch ''all'' errors.

For example, suppose you are writing an extension module to a web service. You want the error information to output the output web page, and the server to continue to run, if at all possible. But you have no idea what kind of errors you might have put in your code.

In situations like these, you may want to code something like this:

{{{
#!python
import sys
try:
  untrusted.execute()
except: # catch *all* exceptions
  e = sys.exc_info()[1]
  write_to_page( "<p>Error: %s</p>" % e )
}}}

MoinMoin software is a good example of where general error catching is good. If you write Moin``Moin extension macros, and trigger an error, Moin``Moin will give you a detailed report of your error and the chain of events leading up to it. Python software needs to be able to catch ''all'' errors, and deliver them to the recipient of the web page.

== Finding Specific Exception Names ==

Standard exceptions that can be raised are detailed at:

  http://python.org/doc/lib/module-exceptions.html

Look to class documentation to find out what exceptions a given class can raise.

= See Also: =

On this wiki: WritingExceptionClasses, TracebackModule.

For general (non-Python specific) ideas about exceptions, consult Wiki:ExceptionPatterns.

= To Write About... =

  * Give example of IOError, and interpreting the IOError code.
  * Give example of multiple excepts. Handling multiple excepts in one line.
  * Show how to use "else" and "finally".
  * Show how to continue with a "raise".

= Questions =

== General Error Handling ==

In the "general error handling" section above, it says to catch all exceptions, you use the following code:

{{{
#!python
import sys
try:
  untrusted.execute()
except: # catch *all* exceptions
  e = sys.exc_info()[1]
  write_to_page( "<p>Error: %s</p>" % e )
}}}

However, it originally was:

{{{
#!python
try:
  untrusted.execute()
except Exception, e:
  write_to_page( "<p>Error: %s</p>" % str(e) )
}}}

Someone pointed out that "except" catches more than just "except Exception, e."

''Why is that the case? What is the difference?''-- LionKimbro

For now (version 2.3) exception doesn't have to be inherited from Exception. Thus plain 'except:' catches all exceptions, not only system. -- MikeRovner [[DateTime(2004-01-19T05:49:19Z)]]

== Getting Useful Information from an Exception ==

So, I've got something like:

{{{
#!python
(a,b,c) = d
}}}

...and Python spits back:

{{{
ValueError: unpack list of wrong size
}}}

...and so, you naturally wonder, "Well, what ''was'' in {{{d}}}?"

You know- you can put a {{{print d}}} in there, and that works. But is there a better, more interesting way to get at that information that people know of?
