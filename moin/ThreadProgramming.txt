= Stopping Threads =

I'd like to start this page off with a question.  How do you kill one thread from within another? Here's some code that shows the problem:

{{{
#!python
import threading
import time

class Worker(threading.Thread):
  def __init__(self, eventChannel, eventHandler):
    self.eventChannel = eventChannel
    self.eventHandler = eventHandler
    self.stopFlag = 0

  def shutdown(self):
    self.stopFlag = 1

  def start(self):
    self.stopFlag = 0
    while not self.stopFlag:
      event = self.eventChannel.waitEvent() # blocking call
      self.eventHandler.dispatchEvent(event)


eventChannel = EventChannel()
eventHandler = EventHandler()
worker = Worker(eventChannel, eventHandler)
worker.start()
time.sleep(20)
worker.shutdown()
}}}
The problem here is that {{{EventChannel.waitEvent()}}} is a blocking operation.  So if no event ever arrives, then our worker thread never stops.  ''({{{EventChannel}}} and {{{EventHandler}}} are classes I've invented for this example)''

== Suggestions ==

 * Make the {{{shutdown()}}} method put some harmless event on the event channel:

{{{
  def shutdown(self):
    self.stopFlag = 1
    self.eventChannel.push_event(NullEvent())
}}}

 * ''any other ideas?''

= Call to C function blocks all threads =

I have a C module that does database queries. Those queries go off to an SQL server
to be processed. I would like to use my query function within threads and to have it work
like {{{time.sleep()}}}, that is, block the current thread until it finishes but allow other threads to continue operation. I haven't seen this issue addressed in any of the books I have.
 
* ''Any suggestions, anyone?''
