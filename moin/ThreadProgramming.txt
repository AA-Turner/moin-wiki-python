= Stopping Threads =

I'd like to start this page off with a question.  How do you kill one thread from within another? Here's some code that shows the problem:

{{{
#!python
import threading
import time

class Worker(threading.Thread):
  def __init__(self, eventChannel, eventHandler):
    self.eventChannel = eventChannel
    self.eventHandler = eventHandler
    self.stopFlag = 0

  def shutdown(self):
    self.stopFlag = 1

  def run(self):
    self.stopFlag = 0
    while not self.stopFlag:
      event = self.eventChannel.waitEvent() # blocking call
      self.eventHandler.dispatchEvent(event)


eventChannel = EventChannel()
eventHandler = EventHandler()
worker = Worker(eventChannel, eventHandler)
worker.start()
time.sleep(20)
worker.shutdown()
}}}
The problem here is that {{{EventChannel.waitEvent()}}} is a blocking operation.  So if no event ever arrives, then our worker thread never stops.  ''({{{EventChannel}}} and {{{EventHandler}}} are classes I've invented for this example)''

== Suggestions ==

 * Make the {{{shutdown()}}} method put some harmless event on the event channel:

{{{
  def shutdown(self):
    self.eventChannel.push_event(NullEvent())
    self.stopFlag = 1
}}}

 * ''any other ideas?''

