#pragma section-numbers off

= Points & Rectangles =

A pair of classes to provide points and rectangles.

Surprisingly, I haven't been able to find a single Python module providing such primitive support.

WxPython supports wxPoint and wxRect, but it lacks many basic functions (such as, say, adding two points together to produce a third point..!)

This code is lacking a zillion essential features (but interpoint distance can now be calculated). I only put in the ones I needed immediately. Please add, refactor, optimize, rename stuff to be more standard, etc., as you see fit..!

''If there's an actual, accessible, easy-to-include Python module, not tied to a graphics library, that does this stuff already, please write about it here! No sense in reinventing the wheel. I've looked, but haven't found one. Hence this.''

{{{
#!python
# Code is Public Domain.

import math # required because of 'sqrt' in 'distanceTo' function 
            # also tan and atan for rotations.

def normalize(x1, y1, x2, y2):
    '''I am not sure what this is for, care to comment?'''
    return min(x1,x2), min(y1,y2), max(x1,x2), max(y1,y2)

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, other):
        return Point(self.x+other.x, self.y+other.y)
    def __sub__(self, other):
        return Point(self.x-other.x, self.y-other.y)
    def __mul__( self, scalar ):
        return Point(self.x*scalar, self.y*scalar)
    def __div__(self, scalar):
        return Point(self.x/scalar, self.y/scalar)
    def __str__(self):
        return "(%s, %s)" % (self.x, self.y)
    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__, self.x, self.y)
    def XY(self):
        '''Returns a tuple (x,y).'''
        return self.x,self.y
    def Clone(self):
        '''Returns a full copy of this point.''' 
        return Point(self.x, self.y)
    def Integerize(self):
        '''Rounds co-ordinate values to integers.'''
        self.x = int(self.x)
        self.y = int(self.y)
    def Floatize(self):
        '''Converts co-ordinate values to floating point (is this necessary?)'''
        self.x = float(self.x)
        self.y = float(self.y)
    def DistanceTo(self,pt):
        '''Distance between 2 points.'''
        dy = self.y - pt.y
        dx = self.x - pt.x
        return sqrt(dy*dy + dx*dx)
    def Move(newx,newy):
        '''Changes coordinates to those given.'''
        self.x = newx
        self.y = newy
    def MoveDelta(dx,dy):
        '''Move to new (x+dx,y+dy)'''
        self.x = self.x + dx
        self.y = self.y + dy
    def Rotate(self,theta):
        '''Clockwise rotation about origin, theta in Degrees.  Returns the new position as Point()'''
        # Err..this math is not exactly readable.  
        # It is elementary though, involving only Pythogoras and basic trig.
        r2 = sqr(self.x)+sqr(self.y)
        tmp = math.tan(theta*math.pi/90 + math.atan(self.x/self.y))
        ret = Point()
        ret.x = math.sqrt(r2/(1+tmp*tmp))
        ret.y = ret.x * tmp
        return ret
    def RotateAbout(self,OtherPoint,theta):
        '''Clockwise rotation about another point.  Returns a Point() at new position'''
        tmpx = OtherPoint.x
        tmpy = OtherPoint.y
        self.MoveDelta(-tmpx,-tmpy)
        tmpPoint = self.Rotate(theta)
        tmpPoint.MoveDelta(tmpx,tmpy)
        return tmpPoint


class Rect:
    def __init__(self, pt1, pt2):
        self.Set(pt1, pt2)
    def Contains(self, pt):
        x,y = pt.XY()
        return self.left <= x <= self.right and self.top <= y <= self.bottom
    def Set( self, pt1, pt2 ):
        extrema = normalize(pt1.x, pt1.y, pt2.x, pt2.y)
        self.left, self.top, self.right, self.bottom = extrema
    def Overlaps(self, other):
        return (self.right > other.left and self.left < other.right
                and self.top < other.bottom and self.bottom > other.top)
    def GetTL(self):
        return Point(self.left, self.top)
    def GetBR(self):
        return Point(self.right, self.bottom)
    def ExpandedBy(self, n):
        p1 = Point(self.left-n, self.top+n)
        p2 = Point(self.right+n, self.bottom+n)
        return Rect(p1, p2)
    def TransformedByFunction(self, foo):
        p1 = Point(self.left,  self.top)
        p2 = Point(self.right, self.bottom)
        return Rect(foo(p1), foo(p2))
    def __str__( self ):
        return "<Rect (%s,%s)-(%s,%s)>" % (self.left,self.top,
                                           self.right,self.bottom)
    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__,
                               Point(self.left, self.top),
                               Point(self.right, self.bottom))

}}}
