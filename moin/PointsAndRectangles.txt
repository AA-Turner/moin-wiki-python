#pragma section-numbers off

= Points & Rectangles =

A pair of classes to provide points and rectangles.

Surprisingly, I haven't been able to find a single Python module providing such primitive support.

WxPython supports wxPoint and wxRect, but it lacks many basic functions (such as, say, adding two points together to produce a third point..!)

This code is lacking a zillion essential features (but interpoint distance can now be calculated). I only put in the ones I needed immediately. Please add, refactor, optimize, rename stuff to be more standard, etc., as you see fit..!

''If there's an actual, accessible, easy-to-include Python module, not tied to a graphics library, that does this stuff already, please write about it here! No sense in reinventing the wheel. I've looked, but haven't found one. Hence this.''

{{{
#!python
# Code is Public Domain.

import math # required because of 'sqrt' in 'distanceTo' function.

def normalize(x1, y1, x2, y2):
    return min(x1,x2), min(y1,y2), max(x1,x2), max(y1,y2)

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, other):
        return Point(self.x+other.x, self.y+other.y)
    def __sub__(self, other):
        return Point(self.x-other.x, self.y-other.y)
    def __mul__( self, scalar ):
        return Point(self.x*scalar, self.y*scalar)
    def __div__(self, scalar):
        return Point(self.x/scalar, self.y/scalar)
    def __str__(self):
        return "(%s, %s)" % (self.x, self.y)
    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__, self.x, self.y)
    def XY(self):
        return self.x,self.y
    def Clone(self):
        return Point(self.x, self.y)
    def Integerize(self):
        self.x = int(self.x)
        self.y = int(self.y)
    def Floatize(self):
        self.x = float(self.x)
        self.y = float(self.y)
    def distanceTo(self,pt):
        '''Distance between 2 points.'''
        dy = self.y - pt.y
        dx = self.x - pt.x
        return sqrt(dy*dy + dx*dx)

class Rect:
    def __init__(self, pt1, pt2):
        self.Set(pt1, pt2)
    def Contains(self, pt):
        x,y = pt.XY()
        return self.left <= x <= self.right and self.top <= y <= self.bottom
    def Set( self, pt1, pt2 ):
        extrema = normalize(pt1.x, pt1.y, pt2.x, pt2.y)
        self.left, self.top, self.right, self.bottom = extrema
    def Overlaps(self, other):
        return (self.right > other.left and self.left < other.right
                and self.top < other.bottom and self.bottom > other.top)
    def GetTL(self):
        return Point(self.left, self.top)
    def GetBR(self):
        return Point(self.right, self.bottom)
    def ExpandedBy(self, n):
        p1 = Point(self.left-n, self.top+n)
        p2 = Point(self.right+n, self.bottom+n)
        return Rect(p1, p2)
    def TransformedByFunction(self, foo):
        p1 = Point(self.left,  self.top)
        p2 = Point(self.right, self.bottom)
        return Rect(foo(p1), foo(p2))
    def __str__( self ):
        return "<Rect (%s,%s)-(%s,%s)>" % (self.left,self.top,
                                           self.right,self.bottom)
    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__,
                               Point(self.left, self.top),
                               Point(self.right, self.bottom))

}}}
