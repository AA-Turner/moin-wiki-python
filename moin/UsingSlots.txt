== Introduction ==
`__slots__` has a mixed reputation in the Python community. On the one hand, they are considered to be popular. Lots of people like using them. Others say that they are badly understood, tricky to get right, and don't have much of an effect unless there are many instances of objects that use them. This article will explain what they are, how, and why to use them, and when not to use them.

== What Is `__slots__` ? ==
`__slots__` are discussed in the Python Language Reference under section 3.3.2, Customizing Attribute Access. The first thing we should understand is that `__slots__` is only used in the context of Python classes. `__slots__` is a class variable that is usually assigned a sequence of strings that are variable names used by instances. For example:
{{{
    class Example():
    __slots__ = ("slot_0", "slot_1")
    
    def __init__(self):
        self.slot_0 = "zero"
        self.slot_1 = "one"
        
x1 = Example()
print(x1.slot_0)
print(x1.slot_1)

    zero
    one
}}}
The `__slots__` declaration allows us to explicitly declare data members, causes Python to reserve space for them in memory, and prevents the creation of `__dict__ ` and `__weakref__` attributes. It also prevents the creation of any variables that aren't declared in `__slots__`.

== Why Use `__slots__`? ==
The short answer is slots are more efficient in terms of memory space and speed of access, and a bit safer than the default Python method of data access. By default, when Python creates a new instance of a class, it creates a `__dict__` attribute for the class. The `__dict__` attribute is a dictionary whose keys are the variable names and whose values are the variable values.  This allows for dynamic variable creation but can also lead to uncaught errors. For example, with the default `__dict__`, a misspelled variable name results in the creation of a new variable, but with `__slots__` it raises in an AttributeError.
{{{
class Example2():
    
    def __init__(self):
        self.var_0 = "zero"
        
x2 = Example2()
x2.var0 = 0

print(x2.__dict__.keys())
print(x2.__dict__.values())
```

    dict_keys(['var_0', 'var0'])
    dict_values(['zero', 0])



```python
x1.slot1 = 1
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    Input In [3], in <module>
    ----> 1 x1.slot1 = 1


    AttributeError: 'Example' object has no attribute 'slot1'
}}}

As mentioned earlier, a `__slots__` declaration uses less memory than a dictionary, and direct memory access is faster than dictionary lookups. `__slots__` variables use dot notation for assignment and referencing in exactly the same way as the default method. But it should be noted that attempting to access the `__slots__` tuple by subscription returns only the name of the variable.


{{{python
x1.__slots__[0]
}}}

    'slot_0'

== Using A List For Slots ==
The previous example used a tuple for the `__slots__` declaration. The Python documentation states that any non-string iterable can be used. This section describes how slots behavior can change when using a list for the declaration. 

For the most part, using a list for the `__slots__` declaration looks and works exactly like using a tuple.
{{{
class Example():
    
    __slots__ = ['_slot_0', '_slot_1']
    
    def __init__(self):
        self._slot_0 = 'This is slot 0'
        self._slot_1 = 'This is slot 1'
}}}
Using the same code as the previous interpreter session will produce exactly the same results. But unlike a tuple, a list is mutable, and there may be cases when we want to use the list. For example, we can implement get and set functions that access the list, as shown below.
{{{   
    def _set(self, _slot, _value):
        self.__slots__[_slot] = _value
        return None
    
    def _get(self, _slot):
        return self.__slots__[_slot]
   
}}}
'''Caution!''' One should exercise care when assigning to the `__slots__` list directly. In this case `__slots__` is interpreted as a class variable, and changing the value of a slot in one instance will propagate that value to all instances.

== Default Values ==
The following text appears in the Python Language Reference section 3.3.2.4.1:

 "`__slots__ `are implemented at the class level by creating descriptors ... for each variable name. As a result, class  attributes cannot be used to set default values for instance variables defined by `__slots__`; otherwise, the class  attribute would overwrite the descriptor assignment."

It is not necessary to explicitly implement descriptors in order to use slots. The point here is that default values cannot be set using class attributes.

{{{
class Example():
    
    __slots__ = ['_slot_0', '_slot_1']
    
    _slot_0 = 'This is slot 0'
    _slot_1 = 'This is slot 1'  

Out:   Value Error: '_slot_0' in __slots__ conflicts with class variable
}}}
Likewise,
{{{
class Example():
    
    __slots__ = ['_slot_0', '_slot_1']
    
    __slots__[0] = 'This is slot 0'
    __slots__[1] = 'This is slot 1'

Out:  Type Error: __slots__ must be identifiers
}}}
If desired, default values for `__slots__` variables may be set in the class `__init__()` method, as shown in previous examples, but it is not necessary to do so. Values may be assigned to slots variables that have not been initialized with default values.
{{{
class Example():
    
    __slots__ = ['_slot_0', '_slot_1']
    
    def __init__(self):   
        return None

>>> x = Example()
>>> x._slot_0 = 'zero'
>>> print(x._slot_0)
Out: zero
}}}
 
== Why Not Use Slots? ==

There may be cases when you might not want to use `__slots__`; for example, if you would like for your class to use dynamic attribute creation or weak references. In those cases, you can add `'__dict__'` or `'__weakref__'` as the last element in the `__slots__` declaration.

Certain Python objects may depend on the `__dict__` attribute. For example, descriptor classes depend on the `__dict__` attribute being present in the owner class. Programmers may want to avoid `__slots__` in any case where another Python object requires `__dict__` or `__weak_ref__`to be present.  According to the Descriptor How To Guide for Python 3.9, the functools.cached_property() is another example that requires an instance dictionary to function correctly. 

== Beyond The Basics ==
There are a few things to be aware of when going beyond the basics.  Slots variables declared in parents are available in child classes. However, child subclasses will get a `__dict__` and `__weakref__` unless they also define `__slots__`, which should only contain names of additional slots. Multiple inheritance with multiple slotted parent classes can be used, but only one parent is allowed to have attributes created by slots. The other bases must have empty slot layouts. For additional details, please see the Python Language Reference, section 3.3.2.4.1.

== Conclusion ==
Slots are a simple, easy to use, efficient, and safe alternative to Python's default method of data access. The only known exception is when another object requires access to the `__dict__` attribute.  
