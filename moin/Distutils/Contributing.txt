= How to contribute to distutils2/packaging =

This document describes a simple workflow that makes it easy to work on a new
feature for distutils2, or to track a difficult bug.  It requires a basic
understanding of Mercurial: clone, update, diff, commit, merge.

All bugs and new features should have a report opened on http://bugs.python.org/
to let developers coordinate (i.e. not duplicate work) and review patches before
they are integrated.  The field named Component should be set to [[http://bugs.python.org/issue?@columns=title,id,activity,status&@sort=activity&@group=priority&@filter=components,status&@pagesize=50&@startwith=0&status=1&components=25&@dispname=distutils2|Distutils2]], to let the maintainers be automatically notified of the report, and Version to 3.3.  Some bugs only use the [[http://bugs.python.org/issue?@columns=title,id,activity,status&@sort=activity&@group=priority&@filter=components,status&@pagesize=150&@startwith=0&status=1&components=3&@dispname=distutils|Distutils]] component.

distutils1 should be considered a maintenance branch of distutils2; even for bugs originally reported against distutils1, patches should be developed against distutils2, unless the bug is reproducible with distutils1 only or targets code removed in distutils2.  There are more tests and more useful support code in distutils2, so it’s easier to work on tests for distutils2 and let its developers will take care of the backport to distutils1.

This page was written with the help of an old version of the [[http://docs.python.org/devguide/|Python developers’ guide]], thanks to its authors.  See also http://mercurial.aragost.com/kick-start/en/tasks/
for another tutorial describing the same workflow, with pictures but without
packaging-specific parts, and the Mercurial wiki: http://mercurial.selenic.com/wiki/NamedBranches


== Getting the codebase ==

Start by creating a directory for your work and clone the Python 3.x
repository:
{{{
$ mkdir cpython && cd cpython
$ hg clone http://hg.cpython.org/cpython#default py3k
}}}

To start working on a feature, clone your local repository:
{{{
$ hg clone py3k add-magic
$ cd add-magic
$ ./configure --with-pydebug && make -s
}}}

You have a working Python, let’s start hacking!


== Starting a branch ==

Start a new named branch with this command:
{{{
$ hg branch mywork
}}}

Now you can edit files, run tests and commit your changes.  Using a named branch
instead of unnamed branches gives you a name, mywork, that you can use with
commands such as hg diff and hg log.  It doesn’t matter how many unclean commits
you make in your branch; {{{hg diff -r default}}} will always show you the result
of the changes in your branch compared to the default branch, in other words
your local work compared to the main repository.

Having this name makes it easy to work on various things, merge regularly with
upstream, generate diffs, fix mistakes, ports some changes upstream directly,
etc.  You can make mistakes and fix them; in the end, you will get one clean
diff to apply.


== Hacking ==

You can work on your feature or bug and commit as needed.  The code lives in
Lib/packaging and its documentation in Doc/packaging, Doc/install and
Doc/library/packaging.*  Some bugs also require editing modules like site or
sysconfig, or their documentation.  Ideally, the first step is to write a test that fails, thus demonstrating the bug, and then change the code to make the test pass.

The [[http://docs.python.org/devguide/|Python developers’ guide]] contains good advice that applies to distutils2
too.  For example, it tells you about the {{{make patchcheck}}} command, to run
from the root of a clone, to perform some checks for common mistakes.

For distutils2, each bug fix should have a test, and each new feature should
have good tests and documentation.  Don’t hesitate to ask for assistance or
advice on the bug report or on the mailing list.


== Staying in sync ==

To make sure that your branch does not get out of sync, which means that the
final diff could not be applied, remember to pull and merge new changesets
regularly:
{{{
$ cd cpython
$ hg pull -u -R py3k
$ hg pull -R add-magic
$ hg pull -R fix-scripts-record
}}}

The first pull command will get new changesets from the repository it was cloned
from, on hg.python.org; the following pull will only transfer changesets
locally, saving you bandwidth and time.  This is why I made you create a base
clone, {{{py3k}}}, and then a clone for each feature or bug.  Pulling in all
clones is easily automated with a shell function.

The next step is the merge itself::
{{{
$ cd add-magic
$ hg branch
mywork
$ hg merge default
}}}

Using {{{hg branch}}} or {{{hg id}}} is a good way to make sure your working copy is
a checkout of the right branch.  {{{hg merge default}}} is the command that lets
you incorporate changes from upstream into your local copy.  If nobody edited
the same files on the same lines, Mercurial will merge everything automatically;
otherwise, you will have to resolve the conflicts with the merge tool that you
configured and that Mercurial launches for you.


== Sharing your work ==

If you don’t have a favorite Mercurial hosting yet, the easiest is to use
Bitbucket.  Log in and visit http://bitbucket.org/mirror/cpython/fork to create
a server-side clone; select “default” in the dropdown menu labeled “fork at” before
submitting, otherwise you will get the Python 2.7 branch, which you don’t need.
Then you can push the changesets from your named branch:
{{{
$ cd cpython/add-magic
$ hg push --new-branch ssh://hg@bitbucket.org/<username>/cpython
}}}

Protip: To make Mercurial remember the URI of the repo to use for push, edit the
file located at add-magic/.hg/hgrc to make it look like this::
{{{
[paths]
default = ../py3k
default-push = ssh://hg@bitbucket.org/<username>/cpython
}}}

Now {{{hg push}}} without arguments will push new changesets to your Bitbucket
clone.

After you’ve pushed, another developer can clone your repo to work with you on
your branch, or you can automatically add a patch to the Python bug tracker.
Let’s try this one.


== Mercurial-Roundup integration ==

On each bug page, there is a [[http://docs.python.org/devguide/triaging#mercurial-repository|field]] called “Remote hg repo”; add the HTTP URI of
your clone on Bitbucket, with the branch name after a {{{#}}} sign, like
{{{http://bitbucket.org/<username>/cpython#mywork}}}.  After this, simply pushing
the “Create Patch” button will generate a diff between the default branch of the
official repo and the head of your named branch.  Anyone with a Roundup account
can now follow the link labeled “review” to see the patch and make comments.
You can then address this comments with a new commit in your repo, push to your
public clone, and “Create Patch” again.

Don’t be worried about the review: Even experimented core developers have their
patches sent back to them for changes.  Getting a review is a sign that your
work is noticed and that progress is made towards including it in the official
repository.  Reply to feedback about the changes, update your patch, ping the maintainers (automatically subscribed to distutils and distutils2 bugs) as needed.


== The end ==

When your patch is in a good shape, a Python core developer can take the patch,
apply it in the default branch of a cpython clone and push it.  You can now
delete your local clone to save some space.

If the issue was about a bug also present in old-school distutils, you can adapt
your fix from Lib/packaging to Lib/distutils and propose this patch.  It’s okay
if you don’t want to, the backport will be done by a distutils maintainer.

It is also possible that your patch is rejected, because the issue is judged
invalid or because the approach taken in the patch is not accepted.  Please do
not take it personally; there are a number of constraints on accepting patches,
and your work is appreciated regardless of the outcome.
