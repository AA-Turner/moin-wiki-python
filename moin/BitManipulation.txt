I'm looking for information on Python bit manipulation, binary manipulation.

It seems that there are no modules for performing Python bit manipulation.

I personally want to be able to:
 * Turn "11011000111101..." into bytes, (padded left or right, 0 or 1,) and vice versa.
 * Slice ranges of bits
 * Rotate bits, addressed by the bit. That is, say: "rotate bits 13-17, wrapping around the edges," or, "rotate bits 13-17, lose bits on the one side, set all new bits to 0."
 * Similarly, revert regions of bits, apply logic to regions of bits, etc.,.
 * Switch Endianness, with different block sizes.
 * Apply operations in block groupings: ex: apply XOR 10101 (5 bits) repeatedly across a field.

The closest thing I've found is [[http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/113799|ASPN: bit-field manipulation.]]

I imagine that there are many more manipulations people would like to do with bits.

== Manipulations ==

To integer.

{{{
#!python
>>> print int('00100001', 2)
33
}}}

To hex string. Note that you don't need to use x8 bits.

{{{
#!python
>>> print "0x%x" % int('11111111', 2)
0xff
>>> print "0x%x" % int('0110110110', 2)
0x1b6
>>> print "0x%x" % int('0010101110101100111010101101010111110101010101', 2)
0xaeb3ab57d55
}}}

To character. 8 bits max.

{{{
#!python
>>> chr(int('111011', 2))
';'
>>> chr(int('1110110', 2))
'v'
>>> chr(int('11101101', 2))
'\xed'
}}}

Characters to integers, but not to strings of 1's and 0's.

{{{
#!python
>>> int('01110101', 2)
117
>>> chr(int('01110101', 2))
'u'
>>> ord('u')
117
}}}

Individual bits.

{{{
#!python
>>> 1 << 0
1
>>> 1 << 1
2
>>> 1 << 2
4
>>> 1 << 3
8
>>> 1 << 4
16
>>> 1 << 5
32
>>> 1 << 6
64
>>> 1 << 7
128
}}}

== Transformations Summary ==

Strings to Integers:
 * {{{"1011101101"}}}: {{{int(str, 2)}}}
 * {{{"m"}}}: {{{ord(str)}}}
 * {{{"0xdecafbad"}}}: {{{int(str, 16)}}} (known to work in Python 2.4)
 * {{{"decafbad"}}}: {{{int(str, 16)}}} (known to work in Python 2.4)

Integers to Strings:
 * {{{"1011101101"}}}: '''built-in to Python 3''' (see below)
 * {{{"m"}}}: {{{chr(str)}}}
 * {{{"0xdecafbad"}}}: {{{hex(val)}}}
 * {{{"decafbad"}}}: {{{"%x" % val}}}

We are still left without a technique for producing binary strings, and decyphering hex strings.

== Hex String to Integer ==

The simplest approach is to use the int type with the ``base`` argument.
{{{
#!python
>>> int('0xff',16)
255
>>> int('d484fa894e',16)
912764078414
}}}



Another approach to decyphering "0xdecafbad" style hex strings, is to use eval:

{{{
#!python
>>> eval("0xdecafbad ")
3737844653L
}}}

However, this could be dangerous, depending on where you're getting your data from.

Here's a function that is safer:

{{{
#!python
def hex_to_integer(h):
    """Convert a hex string to an integer.

    The hex string can be any length. It can start with an 0x, or not.
    Unrecognized characters will raise a ValueError.

    This function released into the public domain by it's author, Lion
    Kimbro.
    """
    num = 0  # Resulting integer
    h = h.lower()  # Hex string
    if h[:2] == "0x":
        h = h[2:]
    for c in h:  # Hex character
        num = num * 16
        if "0" <= c <= "9":
            num = num + (ord(c) - ord("0"))
        elif "a" <= c <= "f":
            num = num + (ord(c) - ord("a"))
            num = num + 10
        else:
            raise ValueError(c)
    return num
}}}

== Integer to Bin String ==

Python 3 supports binary literals (e.g. 0b10011000) and has a bin() function. For older versions:

{{{
#!python
>>> def bin(a):
	s=''
	t={'0':'000','1':'001','2':'010','3':'011',
           '4':'100','5':'101','6':'110','7':'111'}
	for c in oct(a)[1:]:
		s+=t[c]
	return s
}}}


== Python Integers ==

From "The Python Language Reference" page on the Data Model:

"Integers (int)  These represent numbers in an unlimited range, subject to available (virtual) memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of 2â€™s complement which gives the illusion of an infinite string of sign bits extending to the left."

Unless you know you are working with numbers that are less than a certain length, for instance numbers from arrays of integers, shifts, rotations, etc. may give unexpected results. There does not seem to be a way to determine how Python represents a specific integer internally, i.e. how many bytes are used.

The number of the highest bit set is the highest power of 2 less than or equal to the input integer. This is the same as the exponent of the floating point representation of the integer, and is also called its "integer log base 2".(ref.1)

The easiest way to determine the highest bit set is:

{{{#!Python

import math

hiBit = math.floor(math.log(int_type, 2))

}}}

An input less than or equal to 0 results in a "ValueError: math domain error"

The section "Finding integer log base 2 of an integer" on the "Bit Twiddling Hacks"(ref.1) web page includes a number of methods for determining this value for integers of known magnitude, presumably when no math coprocessor is available. The only method generally applicable to Python integers of unknown magnitude is the "obvious way" of counting the number of bitwise shift operations needed to reduce the input to 0.

=== Bit Length Of a Python Integer ===

bitLen() counts the actual bit length of a Python integer, that is, the number of the highest non-zero bit ''plus 1''. Zero, with no non-zero bit, returns 0. As should be expected from the quote above about "the illusion of an infinite string of sign bits extending to the left," a negative number throws the computer into an infinite loop.

The function can return any result up to the length of the largest integer your computer's memory can hold.

{{{#!Python

def bitLen(int_type):
    length = 0
    while (int_type):
        int_type >>= 1
        length += 1
    return(length)

for i in range(17):
     print(bitLen(i))

# results: 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5

}}}

The method using the math module is much faster, especially on huge numbers with hundreds of decimal digits.

=== bitLenCount() ===

In common usage, the "bit count" of an integer is the number of set (1) bits, not the bit length of the integer described above. bitLen() can be modified to also provide the count of the number of set bits in the integer. There are faster methods to get the count below.

{{{#!Python

def bitLenCount(int_type):
    length = 0
    count = 0
    while (int_type):
        count += (int_type & 1)
        length += 1
        int_type >>= 1
    return(length, count)

}}}

== Operations on Integers of Unknown Magnitude ==

Some proceedures don't need to know the magnitude of an integer to give meaningful results.

=== bitCount() ===

The proceedure and the information below were found in "Bit Twiddling Hacks"(ref.1)

 - - - - - - - - - - - - - - - - - - - - - - - -

Counting bits set, Brian Kernighan's way*
unsigned int v;          // count the number of bits set in v
unsigned int c;          // c accumulates the total bits set in v
for (c = 0; v; c++)
{   v &= v - 1;  }       //clear the least significant bit set

This method goes through as many iterations as there are set bits. So if we have a 32-bit word with only the high bit set, then it will only go once through the loop.

* The C Programming Language 2nd Ed., Kernighan & Ritchie, 1988.

Don Knuth pointed out that this method was published by Peter Wegner in CACM 3 (1960), 322. Also discovered independently by Derrick Lehmer and published in 1964 in a book edited by Beckenbach.

 - - - - - - - - - - - - - - - - - - - - - - - -

Kernighan and Knuth, potent endorsements!

This works because each subtraction "borrows" from the lowest 1-bit.
For example:
*        loop pass 1                 loop pass 2
*      101000     101000           100000     100000
*    -      1   & 100111         -      1   & 011111
*    = 100111   = 100000         = 011111   =      0

It is an excellent technique for Python, since the size of the integer need not be determined beforehand.

{{{#!Python

def bitCount(int_type):
    count = 0
    while(int_type):
        int_type &= int_type - 1
        count += 1
    return(count)

}}}

=== parityOf() ===

From "Bit Twiddling Hacks"

Code almost identical to bitCount(), above, calculates the parity of an integer, returning 0 if there are an even number of set bits, and -1 if there are an odd number. In fact, counting the bits and checking whether the result is odd with '''bitcount & 1''' is about the same speed as the parity function.

{{{#!Python

def parityOf(int_type):
    parity = 0
    while (int_type):
        parity = ~parity
        int_type = int_type & (int_type - 1)
    return(parity)

}}}

=== lowestSet() ===

To determine the bit number of the ''lowest'' bit set in an integer, in twos-complement notation '''i & -i''' zeroes all but the lowest set bit. The bitLen() proceedure then determines its position. Obviously, negative numbers return the same result as their opposite. In this version, an input of 0 returns -1, in effect an error condition.

For example:
*    00111000     # 56
*    11001000     # twos complement, -56
* &= 00001000

{{{#!Python

def lowestSet(int_type):
    low = (int_type & -int_type)
    lowBit = -1
    while (low):
        low >>= 1
        lowBit += 1
    return(lowBit)

}}}

=== Single bits ===

The usual single-bit operations will work on any Python integer. It is up to the programmer to be sure that the value of 'offset' makes sense in the context of the program.

{{{#!Python

# testBit() returns a nonzero result, 2**offset, if the bit at 'offset' is one.

def testBit(int_type, offset):
    mask = 1 << offset
    return(int_type & mask)

# setBit() returns an integer with the bit at 'offset' set to 1.

def setBit(int_type, offset):
    mask = 1 << offset
    return(int_type | mask)

# clearBit() returns an integer with the bit at 'offset' cleared.

def clearBit(int_type, offset):
    mask = ~(1 << offset)
    return(int_type & mask)

# toggleBit() returns an integer with the bit at 'offset' inverted, 0 -> 1 and 1 -> 0.

def toggleBit(int_type, offset):
    mask = 1 << offset
    return(int_type ^ mask)

}}}


== Research Links ==

this is the sort of thing we're looking for:
 * [[http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/113799|ASPN: bit-field manipulation]]

related modules:
 * [[http://www.python.org/doc/current/lib/module-array.html|array module]] -- (issued with Python)
 * [[http://www.python.org/doc/current/lib/module-struct.html|struct module]] -- (issued with Python)
 * [[http://www.python.org/doc/current/lib/module-binascii.html|binascii module]] -- (issued with Python)
 * [[http://pyserial.sourceforge.net/|pySerial module]] -- access the serial port

see also: BitwiseOperators
