'''Sprint topics following the NeedForSpeed theme'''

You can add additional topics below.  Please discuss the specific goals and possible approaches to these tasks!

= CPython =

 * CPython 2.5 is slower than CPython 2.4.  See ["/Slowdown"].

 * Evaluate the PEPs for optimizing global and attribute lookups 
   [http://www.python.org/dev/peps/pep-0266/ PEP 266],
   [http://www.python.org/dev/peps/pep-0267/ PEP 267],
   and [http://www.python.org/dev/peps/pep-0280/ PEP 280]

 * Can floating point ops be sped-up by avoiding flag/exception checks at every step?  Can some floating point ops be in-lined in ceval.c?

   TimPeters: By default, CPython does no flag or exception checks on float ops -- the `PyFPE_START_PROTECT` and `PyFPE_END_PROTECT` macros normally have empty expansions.  Inlining is possible but probably undesirable.  Doing masses of fp ops in one gulp via the NumPy (or whatever it's called now) extension is the sanest approach.

 * Implement portions of the decimal module in C

   RichardJones: Looks like this has a good chance of being done in SummerOfCode.

   RaymondHettinger: We can get them off to a good start by laying the groundwork (the C struct, some access macros, and implementing a couple of methods that they can use as a model).

   GeorgBrandl: I've created a skeleton C module since I was expecting to work on this.

 * Build-out struct module to support fast, high-volume binary conversions -- perhaps with regexp analogs such struct.compile() and struct.finditer()

   SeanReifschneider: I am interested in working on this.  First job would be figuring out how to best do this.  Can/should it be any faster than a tight C loop that creates the required objects, I think that may dominate execution speed, but would appreciate input.

   PietDelport:  This would be extremely useful in so many contexts.  I can think of the following sources of inspiration:

    * Erlang's [http://www
