The Boost Python Library allows the use of C/C++ from Python. It is part of the larger boost package (http://www.boost.org).

Use the Boost Python Library to quickly and easily export a C++ library to Python such that the Python interface is very similar to the C++ interface. It is designed to be minimally intrusive on your C++ design. In most cases, you should not have to alter your C++ classes in any way in order to use them with Boost.Python. The system should simply ''reflect'' your C++ classes and functions into Python. 

A summary of the development goals is available on the Python [http://www.python.org/sigs/c++-sig/ C++-sig] page, which also serves as a mailing list for users of both versions of the library. A preview of the v2 documentation is available [http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/*checkout*/boost/boost/libs/python/doc/v2/index.html?rev=HEAD&content-type=text/html here], and instructions for getting started with a prerelease are available upon request. 

More on http://www.boost.org/libs/python/doc/index.html

While v2 is being developed, this page seems like a good place to assemble v2 intro and tutorial.

Various items:
 * ["boost.python/FAQ"]
 * ["boost.python/module"]
 * ["boost.python/class"]
 * ["boost.python/extract"]
 * ["boost.python/object"]
 * ["boost.python/list"]
 * ["boost.python/iterator"]

Tutorial:
 1. boost.python/SimpleExample
 1. boost.python/ExportingClasses
 1. boost.python/OverridableVirtualFunctions 
 1. boost.python/FunctionOverloading 
 1. ["boost.python/Inheritance"]
 1. boost.python/SpecialMethod
 1. boost.python/PeekUnderTheHood 
 1. boost.python/CrossExtensionModuleDependencies 
 1. boost.python/WrappingEnums
 1. boost.python/PointersAndSmartPointers 
 1. boost.python/InternalDataStructures 

----
From David Abrahams:

Boost.Python is designed with the idea in mind that users never touch a Py``Object*.

Boost.Python depends on quite a few of the other boost libraries (possibly a few others):
 *  type_traits
 *  bind
 *  function
 *  mpl - currently in prerelease
 *  smart_ptr

IIUC, ["weave"] can be used for embedding nontrivial C++ code, if you're
willing to stick it all inside one function body. Furthermore, tools like
weave.blitz() can make an enormous difference by compiling an entire C++
expression template corresponding to an arbitrarily complicated Python
expression. Surely that's nontrivial. It's definitely ''cool''. I think weave
offers enormous power to the person who's programming mostly in Python.
