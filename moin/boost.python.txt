The Boost.Python Library binds C++ and Python in a mostly-seamless fashion. It is just one member of the boost C++ library collection at http://www.boost.org.

Use the Boost Python Library to quickly and easily export C++ to Python such that the Python interface is very similar to the C++ interface. It is designed to be minimally intrusive on your C++ design. In most cases, you should not have to alter your C++ classes in any way in order to use them with Boost.Python. The system should simply ''reflect'' your C++ classes and functions into Python. Boost.Python bindings are written in pure C++, using no tools other than your editor and your C++ compiler.

The Python [http://www.python.org/sigs/c++-sig/ C++-sig] serves as a mailing list for users of the library. Documentation for the current release is available at http://www.boost.org/libs/python/. Development documentation, which is usually more up-to-date, is available through the [http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/*checkout*/boost/boost/libs/python/doc/index.html Boost CVSWeb] interface.

This page serves as a forum to gather peoples' experience and as a
cookbook, as it is more dynamic by nature and open to contributors.

Various items:
 * ["/FAQ"]
 * /HowTo
 * /BuildingExtensions
 * ["/module"] level: def,scope
 * ["/class"]
 * ["/extract"]
 * ["/object"]
 * ["/list"]
 * ["/iterator"]
 * /CallPolicy
 * /RuntimeErrors

Tutorial:
 1. /SimpleExample
 1. /ExportingClasses
 1. /OverridableVirtualFunctions
 1. /FunctionOverloading
 1. ["/Inheritance"]
 1. /SpecialMethod
 1. /PeekUnderTheHood
 1. /CrossExtensionModuleDependencies
 1. /WrappingEnums
 1. /PointersAndSmartPointers
 1. /InternalDataStructures

Test cases:
 * /StlContainers

----
From David Abrahams:

Boost.Python is designed with the idea in mind that users never touch a Py``Object*.

Boost.Python depends on quite a few of the other boost libraries (possibly a few others):
 *  type_traits
 *  bind
 *  function
 *  mpl
 *  smart_ptr

IIUC, ["weave"] can be used for embedding nontrivial C++ code, if you're
willing to stick it all inside one function body. Furthermore, tools like
weave.blitz() can make an enormous difference by compiling an entire C++
expression template corresponding to an arbitrarily complicated Python
expression. Surely that's nontrivial. It's definitely ''cool''. I think weave
offers enormous power to the person who's programming mostly in Python.
