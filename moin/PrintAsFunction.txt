This page discusses the benefits of replacing the current `print` statement with an equivalent builtin. The `write` and `writeln` functions presented below do everything the `print` statement does without requiring any hacking of the grammar, and also make a number of things significantly easier.

Guido has made it clear he wants to get rid of the `print` statement in ["Python3.0"]. This page considers why we would want to go that way, and how we can actually get there. It should be turned into a PEP eventually.

=== Benefits of using a function instead of a statement ===
 * Extended call syntax provides better interaction with sequences
 * Keyword argument `sep` allows item separator to be changed easily and obviously
 * Keyword argument `linesep` could optionally allow line separator to be changed easily and obviously
 * Keyword argument `stream` allows easy and obvious redirection
 * The builtin can be replaced for application wide customisation (e.g. per-thread logging)
 * Interacts well with PEP 309's partial function application, and the rest of Python's ability to handle functions

=== Getting there from here ===
The example implementation below shows that creating a function with the desired behaviour is quite straightforward. However, calling the builtin `print` is a problem due to the fact that `print` is a reserved word in Python 2.x. Since the `print` statement will be around until Py3K allows us to break backwards compatibility, devising a transition plan that lets programmers 'get ready early' for the Py3K transition becomes a significant challenge.

If, on the other hand, the builtin has a different name, it is quite feasible to introduce it during the 2.x series. In [http://www.python.org/peps/pep-3000.html PEP 3000], it is suggested that the `print` statement be replaced by two builtins: `write` and `writeln`. These names are used in the example below. By using alternative names, and providing the builtins in the 2.x series, it is possible to 'future-proof' code against the removal of the `print` statement in Py3k.

This technique of having two printing operations is not uncommon - Java has both `print` and `println` methods, and C# has `Write` and `WriteLine`. The main problem with the approach is that the `writeln` form will actually be more commonly used, but has the longer, less obvious name of the two proposed functions. This perception of relative use is based on a comparison of relative usage levels of the two current forms of the `print` statement (i.e., with and without the trailing comma) by some of the developers on python-dev.

Some other names for the builtins which have been suggested are:
 * `print` - excellent name, but causes transition problems as described above
 * `println` - avoids the transition problems, reflects default behaviour of adding a line, matches Java method name
 * `printline` - alternative to `println`, that avoids the somewhat cryptic abbreviation
 * `writeline` - alternative to `writeln` that avoids the somewhat cryptic abbreviation
 * `out` - not a verb, and converting to it may be problematic due to shadowing by variable names
 * `output` - nice symmetry with input, but using the term as a verb is not typical

=== Sample implementation ===
This is a Python 2.4 compatible sample implementation. This version of `writeln` doesn't provide a `linesep` keyword argument in order to keep things simple.

{{{#!python
def write(*args, **kwds):
    """Functional replacement for the print statement

    This function does NOT automatically append a line separator (use writeln for that)
    """

    # Nothing to do if no positional arguments
    if not args:
        return

    def parse_kwds(sep=" ", stream=sys.stdout):
        """ Helper function to parse keyword arguments """
        return sep, stream
    sep, stream = parse_kwds(**kwds)

    # Perform the print operation without building the whole string
    stream.write(str(args[0]))
    for arg in args[1:]:
        stream.write(sep)
        stream.write(str(arg))
        
def writeln(*args, **kwds):
    """Functional replacement for the print statement

    >>> writeln(1, 2, 3)
    1 2 3
    >>> writeln(1, 2, 3, sep='')
    123
    >>> writeln(1, 2, 3, sep=', ')
    1, 2, 3
    >>> import sys
    >>> writeln(1, 2, 3, stream=sys.stderr)
    1 2 3
    >>> writeln(*range(10))
    0 1 2 3 4 5 6 7 8 9
    >>> writeln(*(x*x for x in range(10)))
    0 1 4 9 16 25 36 49 64 81
    """
    # Perform the print operation without building the whole string
    write(*args, **kwds)
    write("\n", **kwds)
}}}

=== Code comparisons ===
These are some comparisons of current `print` statements with the equivalent code using the builtins `write` and `writeln`.

{{{#!python
# Standard printing
print 1, 2, 3
writeln(1, 2, 3)

# Printing without any spaces
print "%d%d%d" % (1, 2, 3)
writeln(1, 2, 3, sep='')

# Print as comma separated list
print "%d, %d, %d" % (1, 2, 3)
writeln(1, 2, 3, sep=', ')

# Print without a trailing newline
print 1, 2, 3,
write(1, 2, 3)

# Print to a different stream
print >> sys.stderr, 1, 2, 3
writeln(1, 2, 3, stream=sys.stderr)

# Print a simple sequence
print " ".join(map(str, range(10)))
writeln(*range(10))

# Print a generator expression
print " ".join(str(x*x) for x in range(10))
writeln(*(x*x for x in range(10)))
}}}

=== Newline / No-newline ===
Another possibility to deal with the newline / no-newline cases would be to have a single function which would take an extra keyword argument "linesep" or "end" (or perhaps some slight magic: an empty string as the last argument), so to print without newline, you would do

{{{#!python
# Print without a trailing newline
print 1, 2, 3,
writeln(1, 2, 3, end='')
# or (shorthand)
writeln(1, 2, 3, '')
}}}

The default case should be to insert a newline.

  I quite like the single function idea (early versions of this Wiki page used only a single function), but giving it a good name is challenging. The version without the keyword argument is a definite non-starter, though, as there is far too much risk of quirky behaviour when printing a string variable which just happens to contain the empty string. - ''Nick Coghlan''

=== Iterating Iterables ===

Another potentially interesting improvement could be for the function to iterate all iterables, in order to be able to use generator expressions without having to use the star syntax and to avoid the creation of a temporary sequence.  This would allow:

{{{#!python
# Print a generator expression
print " ".join(str(x*x) for x in range(10))
writeln(x*x for x in range(10))
# Or optionally
writeln((x*x for x in range(10)), iter=1)
}}}

This behaviour could be optionally triggered by a keyword argument "iter".
Another possibility would be to always do the iteration and to force the caller to str() the generator if he wants to print it without iteration (happens rarely).

  Nailing down this kind of behaviour is trickier than one might think. The python-dev discussion of the Python 2.5 candidate library function [http://mail.python.org/pipermail/python-dev/2005-March/052215.html itertools.walk] goes over some of the potential problems. We've survived without fancy iterator handling in the print statement - let's avoid adding anything we don't have a demonstrated need for (the extended call syntax stuff comes 'for free' with the conversion to using a function). - ''Nick Coghlan''

=== Another Strawman ===
Here's my own strawman implementation of {{{write()}}} and {{{writef()}}} using semantics I think are pretty useful.  I'll post to python-dev about the details. - ''Barry Warsaw''

{{{#!python
import sys
from string import Template

class Separator:
    def __init__(self, sep):
        self.sep = sep

SPACE = Separator(' ')
EMPTY = Separator('')


def writef(fmt, *args, **kws):
    if 'to' in kws:
        to = kws.get('to')
        del kws['to']
    else:
        to = sys.stdout
    if 'nl' in kws:
        nl = kws.get('nl')
        del kws['nl']
        if nl is True:
            nl = '\n'
        elif nl is False:
            nl = ''
    else:
        nl = '\n'
    if isinstance(fmt, Template):
        if args:
            raise TypeError('invalid positional arguments')
        s = fmt.substitute(kws)
    else:
        if kws:
            raise TypeError('invalid keyword arguments')
        s = fmt % args
    to.write(s)
    to.write(nl)


def write(*args, **kws):
    if 'to' in kws:
        to = kws.get('to')
        del kws['to']
    else:
        to = sys.stdout
    if 'nl' in kws:
        nl = kws.get('nl')
        del kws['nl']
        if nl is True:
            nl = '\n'
        elif nl is False:
            nl = ''
    else:
        nl = '\n'
    if 'sep' in kws:
        sep = kws.get('sep')
        del kws['sep']
    else:
        sep = ' '
    if kws:
        raise TypeError('invalid keyword arguments')
    it = iter(args)
    # Suppress leading separator, but consume all Separator instances
    for s in it:
        if isinstance(s, Separator):
            sep = args[0].sep # Should this be s.sep?
        else:
            # Don't write a leading separator
            to.write(str(s))
            break
    for s in it:
        if isinstance(s, Separator):
            sep = s.sep
        else:
            to.write(sep)
            to.write(str(s))
    to.write(nl)


obj = object()
refs = sys.getrefcount(obj)

write('obj:', obj, 'refs:', refs)
write(Separator(': '), 'obj', obj,
      Separator(', '), 'refs',
      Separator(': '), refs,
      nl=False)
write()

writef('obj: %s, refs: %s', obj, refs)
writef(Template('obj: $obj, refs: $refs, obj: $obj'),
       obj=obj, refs=refs,
       to=sys.stderr,
       nl=False)
write()}}}

  For the code comparisons shown earlier, simply put `write` where `writeln` is currently used, and add the keyword argument `nl=False` for the no trailing newline case. I quite like this approach. - ''Nick Coghlan''

=== Another variant - `format` builtin ===
Barry's `writef` builtin cuts down a little on the typing, but is somewhat inflexible in that it only supports `string %` or `string.Template` formatting when printing directly to a stream. It also causes problems by preventing the use of `to` or `nl` as keywords in the format string. A separate `format` builtin would deal with both of those problems, at the expense of some extra typing when using it. Such a builtin would also help with avoiding some of the tuple related quirks of the string mod operator, as well as making it easy to write code that supports both types of string formatting. The version below is based on Barry's, but eliminates the `Separator` concept, and replaces `writef` with `format` - ''Nick Coghlan''

{{{#!python
import sys
from string import Template

# Real implementation would avoid blocking use of 'fmt'
# as an element of the formatting string
def format(fmt, *args, **kws):
    if isinstance(fmt, Template):
        if args:
            raise TypeError('invalid positional arguments')
        s = fmt.substitute(kws)
    else:
        if kws:
            s = fmt % kws
        else:
            s = fmt % args
    return s


def write(*args, **kws):
    if 'to' in kws:
        to = kws.get('to')
        del kws['to']
    else:
        to = sys.stdout
    if 'nl' in kws:
        nl = kws.get('nl')
        del kws['nl']
        if nl is True:
            nl = '\n'
        elif nl is False:
            nl = ''
    else:
        nl = '\n'
    if 'sep' in kws:
        sep = kws.get('sep')
        del kws['sep']
    else:
        sep = ' '
    if kws:
        raise TypeError('invalid keyword arguments')
    for s in args[:1]:
        to.write(str(s))
    for s in args[1:]:
        to.write(sep)
        to.write(str(s))
    to.write(nl)


obj = object()
refs = sys.getrefcount(obj)

write('obj:', obj, 'refs:', refs)
write('obj:', obj, 'refs:', refs, sep=', ', nl=False)
write()

write(format('obj: %s, refs: %s', obj, refs))
write(format('obj: %(obj)s, refs: %(refs)s', obj=obj, refs=refs))
write(format(Template('obj: $obj, refs: $refs, obj: $obj'),
              obj=obj, refs=refs),
       to=sys.stderr,
       nl=False)
write()
}}}
