This page discusses the benefits of replacing the current `print` statement with an equivalent builtin. The `println` function presented below does everything the `print` statement does without requiring any hacking of the grammar, and also makes a number of things significantly easier.

=== Benefits of using a function instead of a statement ===
 * Extended call syntax provides better interaction with sequences
 * Keyword argument `sep` allows separator to be changed easily and obviously
 * Keyword argument `lnterm` allows line terminator to be changed easily and obviously
 * Keyword argument `stream` allows easy and obvious redirection
 * The builtin can be replaced for application wide customisation (e.g. per-thread logging)
 * Interacts well with PEP 309's partial function application

=== Getting there from here ===
The example implementation below shows that creating a function with the desired behaviour is quite straightforward. A problem only arises if we decide we want the builtin to have the name `print`. This seriously complicates transition, because `print` is a reserved word in Python 2.x. Since the `print` statement will be around until Py3K allows us to break backwards compatibility, devising a transition plan that lets programmers 'get ready early' for the Py3K transition becomes a significant challenge.

If, on the other hand, the builtin had a different name (such as `println`), it would be quite feasible to introduce it during the 2.x series, with the only change in Py3K being the final removal of the `print` statement.

=== Sample implementation ===
This is a Python 2.4 compatible sample implementation, which is why it uses the name `println` rather than `print`.

{{{#!python
def println(*args, **kwds):
    """Functional replacement for the print statement

    >>> println(1, 2, 3)
    1 2 3
    >>> println(1, 2, 3, sep='')
    123
    >>> println(1, 2, 3, sep=', ')
    1, 2, 3
    >>> println(1, 2, 3, lnterm='Alternate line terminator\n')
    1 2 3Alternate line terminator
    >>> import sys
    >>> println(1, 2, 3, stream=sys.stderr)
    1 2 3
    >>> println(*range(10))
    0 1 2 3 4 5 6 7 8 9
    >>> println(*(x*x for x in range(10)))
    0 1 4 9 16 25 36 49 64 81
    """
    # Parse the keyword-only optional arguments
    defaults = {
        "sep": " ",
        "lnterm": "\n",
        "stream": sys.stdout,
    }
    for name, default in defaults.items():
        item = None
        try:
            item = kwds[name]
        except KeyError:
            pass
        if item is None:
            kwds[name] = default
    sep, lnterm, stream = kwds["sep"], kwds["lnterm"], kwds["stream"]
    # Perform the print operation without building the whole string
    for arg in args[:1]:
        stream.write(str(arg))
    for arg in args[1:]:
        stream.write(sep)
        stream.write(str(arg))
    stream.write(lnterm)
}}}

=== Code comparisons ===
These are some comparisons of current print statements with the equivalent code using the builtin.

'''Standard printing:'''
{{{#!python
print 1, 2, 3
println(1, 2, 3)
}}}

'''Printing without any spaces:'''
{{{#!python
print "%d%d%d" % (1, 2, 3)
println(1, 2, 3, sep='')
}}}

'''Print as comma separated list:'''
{{{#!python
print "%d, %d%, d" % (1, 2, 3)
println(1, 2, 3, sep=', ')
}}}

'''Print without a trailing newline:'''
{{{#!python
print 1, 2, 3,
println(1, 2, 3, lnterm='')
}}}

'''Print to a different stream:'''
{{{#!python
print >> sys.stderr, 1, 2, 3
println(1, 2, 3, stream=sys.stderr)
}}}

'''Print a simple sequence:'''
{{{#!python
print " ".join(map(str, range(10)))
println(*range(10))
}}}

'''Print a generator expression:'''
{{{#!python
print " ".join(str(x*x) for x in range(10))
println(*(x*x for x in range(10)))
}}}
