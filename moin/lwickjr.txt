Welcome to my page.
----
After reading Wiki:RealNamesPlease, Wiki:RealNamesPleaseDiscussion, and Wiki:OneNamePlease,

I respectfully decline to change my login ID.

This is the ID I use exclusively online, it is derived from my "RL" name, and it is the ID under which I recieve my e-mail.

In accordance with Wiki:OneNamePlease and Wiki:RealNamesPleaseDiscussion, I conclude that while "lwickjr" is not "exactly" in accordance with Wiki:RealNamesPlease, it IS "close enough".

Please, no flames; no offense intended.
----
If anyone with GOOD American-English spelling skills would care to proofread this page and correct any spelling errors that I can't find, feel free. I've been adding known-correctly-spelled words to the online spelling checker, but I'm a tad unsure of a few of my spellings.
----
I have a few questions that I've been unable to find answer for.

All the documentation I've seen seems to assume that someone wanting to publish Python modules has -- and knows how to use -- a 24/7 file server available to use.

This is not always the case.

Further, I have found the documentation on distributing Python modules to be strong on the mechanicals of how to PACKAGE modules [somewhat over-kill, I think, for simple drop-in single-file modules], and nearly non-existant on how to PUBLISH them.

Could someone __please__ write a page on ["How to publish Python modules"] that is understandable by someone with significant *computer* experience but minimal *internet* experience?

== Links  ==

SkipMontanaro

----

Hi lwick, before I answer some of your questions, I'd like you to consider Wiki:RealNamesPlease. It is one of our WikiGuidelines, and it has worked well for us so far.

I'm not completely sure what you mean by publishing Python modules. If you need a space to upload your Python modules, you might want to consider StarshipPython. It used to be free for PSA members, but the PSA has ceased to exist, so I guess a small donation to the PythonSoftwareFoundation will do now. Would that solve your problem?

-- JohannesGijsbers

["lwickjr"]: Possibly. I've written a few useful-to-me modules that I think others might also find useful. I'd like to share them, but I am NOT on-line 24/7, and would like someone to host them for downloading. As for ["WikiName"]s, would LWickJr do? If so, how do I change it?

With a real name I meant the one in your passport, not capitalizing your nick into a WikiName. Changing it is easy: just create the new page and cut all content from this page into it. Then delete this page and log in using your new name. -- JohannesGijsbers

["lwickjr"]: Don't have a passport. As for my "nick", the L is my first inital, the Wick is my family name, and the Jr is because I've got the same name as my father. Isn't this "real" enough?

 /--- later the same day ---
  Having read Wiki:RealNamesPlease, Wiki:RealNamesPleaseDiscussion, and Wiki:OneNamePlease, I choose to continue using ["lwickjr"] as my login name. It is a persistant on-line identity. It is directly related to my given name. It is the *only* ID I use online. I doubt that anyone here would like to call me "the Hungry Hacker", with which I sign all my e-mail.

  Having stated my position, I simply shall ignore the issue and contribute as best I can. After all, isn't that why we're here?

  No offense taken; none intended.
 \---

BTW, what do you think of the modules I describe below?
----

My more-interesting modules [by the way, how do I link to a Wiki page with text that doesn't match the destination page's name?] include "Alias", "Edit", and "UT". I'll add others to this page as I have opportunity [the machine I'm typing this on isn't my home system].

General outlines:

 * Alias
   * Provides a mechanism whereby arbitrary callables are *effectively* converted to commands in interactive Python, but not in modules. To do this, Alias splits off the first word of the command line, attempts to evaluate it, and iff it is callable, the tail of the command is also evaluated and passed to the callable as an argument tuple. This allows the manual use of "dir", "reload", et al, as statements without requiring that parentheses be typed. Parentheses are still required in module source, however, and in any function calls in the tail of the command line.
   * Provides a mechanism whereby arbitrary one-word names may be assigned to callable objects for use with the preceding mechanism. This allows one to dispense with the requirement to type fully-qualified long.nested.module.names for selected callables, and is where the module gets its name.
   * Provides a mechanism for allowing modules to be imported through a bare reference to the module name.
   * Provides a mechanism whereby modules imported by the preceding mechanism may auto-register aliases of their own choosing. Entering the name of a module that has already been imported does not re-import the module; rather it re-updates whatever auto-alias associations might exist in that module at the time the name is re-entered.
   * Provides its own list of aliases, available via the preceding mechanism, for managing the alias dictionary.
   * Does not function under IDLE without disabling the default sub-process. Probably does not function correctly, or even at all, without IDLE.
 * Edit
   * Provides an Alias that attempts to open for editing the source for the module where the argument was defined, positioned, if possible, on the line where the definition starts.
   * Provides a mechanism for recording the current size and position of the active IDLE window such that subsequent attempts to open the window open it with the remembered geometry.
   * Provides an IDLE menu item to trigger the preceding mechanism.
   * Functions only under IDLE. Does not function correctly without disabling the default sub-process.
 * UT
   * Provides several "utility" functions that I've found useful:
   * A "smart" reload substitute that can automatically re-load other modules in dependancy-order, if the module being reloaded registers its dependancies.
   * A convenience wrapper for cPickle that allows [un-]pickling single objects from/to a specified file with a single function call.
   * Others that I don't recall at the moment.
----

I have a hard time understanding what the modules are for; There's a lot of focus on ''how'' these things work, but I have difficulty figuring out what they are for.

It seems to me that Edit is something that makes it so that you can jump straight to where a variable is defined, in IDLE. (Not really sure.) If so, that's awesome! I've often times wished IDLE were more powerful; This is the kind of thing I'd like to see more of. :)

As for publishing modules, it seems to me that we in the Python community are not yet [http://rubyforge.org/softwaremap/trove_list.php as organized as the Ruby community.]

For the most part, people set up their own website, maybe something on SourceForge, get a listing on PyPi or the vaults (of what-I-cant-spell,) and mention it on the python-announce usenet forum.

It would be a good subject for a new wiki page. I think there's already one that's started somewhere, that it would be worthwhile to revisit.

-- LionKimbro [[DateTime(2005-04-01T21:16:29Z)]]

["lwickjr"]: Um, sorry about that. The descriptions are heavy on *what* the modules do, but totally void of either of how they work or why one would want to use them.

Alias is a convenience module for I.D.L.E. PyShell usage, intended to save typing.

UT is a convenience module for miscelaneous support functions that I`ve found useful.

As for Edit, you have the right idea, but variables are too simple for Edit to deal with. When you type "edit thing", "thing" *MUST* evaluate to an object for which one of the standard modules, "inspect", I believe, is capable of locating the information required to open the source module. For the module to open for editing at the line where the object is defined, it is required for perfect positioning that inspect be capable of determining the line number. In the absence of reliable information, Edit makes an educated guess, and positions the editor there. When the educated guess fails, the editor is positioned wherever I.D.L.E. would have positioned it had you opened the file for editing via another method. Basically, Edit is given a class, instance, module, etc., and attempts to display the Python source for the definition. Edit will work, however, for anything that Inspect can retrieve the required information from. Edit also provides a hook for invoking custom editors in place of I.D.L.E.`s built-in editor. This would be useful, for example, for having edit invoke a G.U.I. editor instead when invoked on objects created by the G.U.I. editor.

As for that WIKIPage you mention, ["How to publish Python modules"], I created it in hopes that someone would populate it with useful information. I'm thinking of doing just that. Ok, people, just how big is "small enough"? Does Edit interest you? Don't forget: it *does* require that the default subprocess be turned off, as it REQUIRES interaction between the user dataspace and the I.D.L.E. dataspace, and I don`t [currently] know how to use the IPC [Inter-Process Communication] that I.D.L.E. uses for the purpose. Alias has the same requirement, and for the same reason.

Sombody else (Who?): You`re right, it *is* worth revisiting, in case someone _has_ done just that. Someone suggested that small modules can be posted here.

["lwickjr"]: Yes; I've seen that.

["lwickjr"]: Please note: 
["How to publish Python modules"] has been superceeded by PublishingPythonModules.

I'm uploading some of my more publishable modules as attachments to this page."Alias" is in ["attachment:lwickjr.Module.Alias"], "Edit" is in ["attachment:lwickjr.Module.Edit"], and "UT" is in ["attachment:lwickjr.Module.UT"]. I *hope* they're not to big.
