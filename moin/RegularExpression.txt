#pragma section-numbers off

 * PythonLibraryReference, [http://www.python.org/doc/current/lib/module-re.html 4.2 re module]
 * PythonLibraryReference, [http://www.python.org/doc/current/lib/re-syntax.html 4.2.1 Regular Expression Syntax]


== Reference Diagrams ==

http://taoriver.net/img/for_pi/regex_characters.png

flags when compiling:

http://taoriver.net/img/for_pi/regex_flags.png

(All images PD, released by me, author, LionKimbro.)

DavidMertz has also created [http://gnosis.cx/TPiP/regex_patterns.gif a regular expression reference.]

== Searching & Matching ==

You can ''search'' or ''match.''
 * ''search'' -- find something ''anywhere'' in the string, and return it
 * ''match'' -- find something ''from the beginning'' of the string, and return it

You can also ''split'' on a pattern.

For example:

{{{
#!python
import re
split_up = re.split(r"(\(\([^)]+\)\))",
                    "This is a ((test)) of the ((emergency broadcasting station.))")
}}}

...which produces:

{{{
["This is a ", "((test))", " of the ", "((emergency broadcasting station.))" ]
}}}

== Compiling ==

If you use a regex a lot, ''compile it'' first.

Consider:

{{{
#!python
import re
match_obj=re.match("<(.*?)>(.*?)</(.*?)>", "<h1>robot</h1>")
print mo.groups()
}}}

...which outputs: {{{('h1', 'robot', 'h1')}}}

If you were going to do that match a lot, you could compile it, like so:

{{{
#!python
import re
match_re=re.compile("<(.*?)>(.*?)</(.*?)>")
match_obj=match_re.match("<h1>robot</h1>")
print match_obj.groups()
}}}

...which yields the same result.

I don't know how much faster compiled forms are than non-compiled forms.

= Links =

 * [http://www.amk.ca/python/howto/regex/ Regular Expression HOWTO] - excellent Python-based regular expression tutorial, by [http://www.amk.ca/ A.M. Kuchling.]

For those interested in visualization, you may also be interested in a [http://www.ozonehouse.com/mark/blog/code/PeriodicTable.pdf periodic table of PERL operators.]

= Discussion =

I've made a couple of diagrams, which I've linked at the top of the page here.

I have SVG links as well; [http://taoriver.net/img/for_pi/regex_characters.svg first] and [http://taoriver.net/img/for_pi/regex_flags.svg second.]

Damn the [http://visual.wiki.taoriver.net/moin.cgi/LongImageIncorporationProcess LongImageIncorporationProcess!] Damn it to hell! We'd have a billion pretty pictures here, if tablets were cheap, and we had protocols and implementations for saving and loading straight to and from the wiki.

I have another diagram I'd like to make and place; It's the pattern (RegexObject) and match (MatchObject) API, visualized, and arranged dense. We'll see if I get around to drawing it, but it looks like no. Too much else to do.

-- LionKimbro [[DateTime(2004-12-28T08:38:12Z)]]


  ''I like the Venn diagram in this image.  However, one part of the image is confusing. Where it refers to python strings, and "regex strings" (which are actually Python "raw" strings) and something called "match strings" ... what are these "match strings. -- JimD [[DateTime(2004-12-30T20:03:54Z)]]''

The image isn't meant to be explanatory, it is meant to be reference and refreshing material.

That said: The "match string" is the final product of either of the two above expressions. It is what the above two expressions will literally match. If you have a better phrase, or would like to correct "raw" to "regex," feel free to download the SVG, edit the text, place an image on the web, and link it from here. (The damn [http://visual.wiki.taoriver.net/moin.cgi/LongImageIncorporationProcess LongImageIncorporationProcess] strikes again.) I may eventually get around to it myself one day, but it seems there are higher priorities, and the diagram is "good enough."

That said, I appreciate the correction. -- LionKimbro [[DateTime(2005-01-01T00:22:14Z)]]
