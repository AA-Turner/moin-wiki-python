`CallPolicy` allows ["boost.python"] to deal with raw references and pointers.
Different policies specifies different strategies of managing object ownership.

[[TableOfContents]]

== with_custodian_and_ward ==
ties lifetimes of the arguments

== with_custodian_and_ward_postcall ==
ties lifetimes of the arguments and results

== return_internal_reference ==
Builds a Python object around a pointer to
the C++ result object (which must have a class_<> wrapper somewhere),
and applies some lifetime management to keep the "self" object alive
as long as the Python result is alive. 

== return_value_policy<T> ==
with T one of:

=== reference_existing_object ===
na√Øve (dangerous) approach

["boost.python/ResultConverterGenerator"] which can be used to wrap C++ functions returning 
a reference or pointer to a C++ object. 

When the wrapped function is called, the value referenced by its return value is not copied. [[BR]]
A new Python object is created which contains an unowned U* pointer to the referent of the wrapped function's return value, and no attempt is made to ensure that the lifetime of the referent is at least as long as that of the corresponding Python object.

This class is used in the implementation of return_internal_reference.

=== copy_non_const_reference ===

=== copy_const_reference ===
BoostPython v1 approach

=== manage_new_object ===
BoostPython/ResultConverterGenerator which can be used to wrap C++ functions returning 
a pointer to an object allocated with a ''new-expression'' and
expecting the caller to take responsibility for deleting that C++ object from heap.
["boost.python"] will do it as part of Python object destruction.

Use case:
{{{
T* factory() { return new T(); }

class_<T>("T");

def("Tfactory", factory, return_value_policy<manage_new_object>() );
}}}

=== return_by_value ===
["boost.python/ResultConverterGenerator"] which can be used to wrap C++ functions returning 
any reference or value type.[[BR]]
The return value is copied into a new Python object.
