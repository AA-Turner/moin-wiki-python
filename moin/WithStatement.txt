This page is dedicated to the public discussion of [http://www.python.org/peps/pep-0343.html PEP 343]: Anonymous Block Redux and Generator Enhancements.

I think this is a good one; I hope people agree. Its acceptance will
obsolete about 4 other PEPs! (A sign that it fulfills a need and that
the proposed solution is powerful.)

Please read the PEP; then add your comments here.  Please sign your comments with your name.  ["GvR"] (Guido van Rossum)

----

I feel like PEP 343 and PEP 342 work together in some important way, but it's not clear what that is.  Does one depend on the other?  What kind of things are possible if both are accepted (vs. just one of them)?  I think this is important to understanding where PEP 343 is leading; some discussion of this would be appreciated.  -- IanBicking

  No, they are quite independent.  PEP 342 is for making generators into real coroutines.  Maybe throw() can help a tiny bit there but I think it's not essential.  PEP 342 adds argument-less yield to PEP 343 which is a very minor improvement (no "yield None").  ["GvR"]

----

The optional extension mentioned would not need to lead to mistakes if the __exit__ call would distinguish between 'with X' and 'with X as Y'. -- ''Eric Nieuwland''

  Please explain.  ["GvR"]

----

next_throw() is easier to grep with next(). ''Niki Spahiev''

----

I've tuned out the recent conversation on these PEPs quite religiously, because I never thought they would result in anything even vaguely useful.  Fortunately, I was dead wrong.  PEP-343 is simple, elegant, and feels very Pythonic to me.  I need to catch up now and think through the implications and corner-cases, but I can give a provisional +1 to the concept.  Thanks to all those that didn't tune out and worked to get us to this point.  -- ''Kevin Jacobs''


----

A few immediate comments:  

 1. Is g.throw(...) supposed to let you raise exceptions in other threads (by having g catch the exception you throw it, then raise its own exception for its caller)?  The PEP should be clear about this.  It would be great if the answer is yes and if that's the case, objects like queues and sockets should be turned into generators to permit cross-thread signalling using generator exceptions.  But I had the impression that this would be difficult in CPython.

     This is not the intention at all.  The PEP specifically speaks
     of "where the generator g is currently suspended".
     By definition this implies that it is not running in another
     thread.  You must have had threads on your mind too much
     recently to even think of this. :-)  ["GvR"]

         I will read it again, but I don't remember seeing anything that
         made me think the generator couldn't be suspended in another thread.  phr

             Generators aren't tied to a thread, but they can only be executing
             in one thread at a time.  When a generator yields in one thread,
             another thread can resume it with next() or throw() -- but then
             the resumed generator executes in the thread that called next()
             or throw().  There's nothing new to this -- it's been like this
             since generators were invented.  ["GvR"]

 1. I thought some of the original motivation of PEP 310 was to lessen the pain of giving up the idiom of expecting files to be closed when their last reference goes away.  So if 343 no longer guarantees that the exit method will be run when the "with" statement finishes, it's lost some of its main motivating functionality.  I  wonder if having a more serious treatment of block scope, so that destructors are guaranteed to be called when a scope exits (by falling through or via an exception), would also take care of this issue.

    Where did you read that the exit method isn't guaranteed to be
    called upon exit from the with statement?  The translation explicitly
    calls it!  Read again.  
    You may be confused with g.close().  That's only relevant when you
    use a for-loop without an explicit with-statement. ["GvR"]

There was some good discussion on clpy a while ago that I'll try to locate, and add some more comments during the weekend.   --Paul Rubin (phr)  


----

Overall I think this is a great proposal. It will allow a lot of things to be made a great deal more natural - probably many things that have not yet been considered.

I can see a lot of areas in the standard libs where improvements could be made using this construct. It will seem slightly inconsistent in areas where this is not done.

The only negative to the proposal is the extra complexity. The idea is a little magical, and may not be easy for new users to pick up. New users will not be forced to use it of course. However ironically the very usefulness of the idiom will probably lead to it being widely used in libraries, which will of course require new users to learn it sooner or later!

-- MichaelSmith


----

I like the idea and the "with .. as .." syntax, where readable keywords are used instead of obscure characters, like decorators use. It looks like Python to me. What I don't like is the use of decoratorated generators to create the templates. Generators don't seem to fit the problem here. First you have to add generator enhancements. Then you use a decorator, because the enhancements still don't make generators fit the problem. It is almost like generators and decorators are the latest and coolest additions to the language, so we're going to use them for everything we possibly can. I find example 4, using a simple class, to be much more readable than example 1. To me, example 4 shows the relative DISadvantage of using a generator template. I would dump the generator changes and just keep the with statement. 

Patrick Ellis

    Well, you have a choice not to use generators. :-)
    To many who participated in the discussion on python-dev, using generators
    to write templates is an essential part.  The more state you carry over
    from __enter__ to __next__ the more you will appreciate the generator.  ["GvR"]

----

What happened to Fredrik Lundh's proposal (14/5/2005) to use the existing 'try' keyword instead of 'with', eg:

try opening(file) as f: ...

try locking(mutex): ...

try atomic_transaction(connection): ...

Try already has the idea of doing cleanup at block exit. I saw only reply in support of the idea on the list, but no other comments.

Thomas Leonard

    When this were combined with an except or finally clause, it would be
    confusing to the reader which applies to which -- does the except clause
    catch exceptions in the __exit__ method, or does the __exit__ method see
    exceptions raised in the except clause?  ["GvR"]
